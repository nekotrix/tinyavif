#!/usr/bin/env python3
"""
Tinyavif - the world's most minimal AV1 encoder
Python port of the Rust implementation

Copyright (c) 2024-2025, The tinyavif contributors. All rights reserved

This source code is subject to the terms of the BSD 2 Clause License and
the Alliance for Open Media Patent License 1.0. If the BSD 2 Clause License
was not distributed with this source code in the LICENSE file, you can
obtain it at www.aomedia.org/license/software. If the Alliance for Open
Media Patent License 1.0 was not distributed with this source code in the
PATENTS file, you can obtain it at www.aomedia.org/license/patent.
"""

from typing import Any, Callable, List, Tuple, Optional, Union, BinaryIO
from dataclasses import dataclass
from pathlib import Path
import argparse
import struct
import time

# ============================================================================
# cdf.py - src/cdf.rs
# ============================================================================

PARTITION_8X8_CDF = [19132, 25510, 30392]

PARTITION_16X16_CDF = [
    [15597, 20929, 24571, 26706, 27664, 28821, 29601, 30571, 31902],
    [7925, 11043, 16785, 22470, 23971, 25043, 26651, 28701, 29834],
    [5414, 13269, 15111, 20488, 22360, 24500, 25537, 26336, 32117],
    [2662, 6362, 8614, 20860, 23053, 24778, 26436, 27829, 31171]
]

PARTITION_32X32_CDF = [
    [18462, 20920, 23124, 27647, 28227, 29049, 29519, 30178, 31544],
    [7689, 9060, 12056, 24992, 25660, 26182, 26951, 28041, 29052],
    [6015, 9009, 10062, 24544, 25409, 26545, 27071, 27526, 32047],
    [1394, 2208, 2796, 28614, 29061, 29466, 29840, 30185, 31899]
]

PARTITION_64X64_CDF = [
    [20137, 21547, 23078, 29566, 29837, 30261, 30524, 30892, 31724],
    [6732, 7490, 9497, 27944, 28250, 28515, 28969, 29630, 30104],
    [5945, 7663, 8348, 28683, 29117, 29749, 30064, 30298, 32238],
    [870, 1212, 1487, 31198, 31394, 31574, 31743, 31881, 32332]
]

# Block mode syntax
SKIP_CDF = [31671]
Y_MODE_CDF = [15588, 17027, 19338, 20218, 20682, 21110, 21825, 23244, 24189, 28165, 29093, 30466]
UV_MODE_CDF = [10407, 11208, 12900, 13181, 13823, 14175, 14899, 15656, 15986, 20086, 20995, 22455, 24212]

# Residual syntax
ALL_ZERO_CDF = [
    # qctx = 0
    [ 
        # 4x4
        [
            [31849], [5892], [12112], [21935], [20289], [27473], [32487], [7654], 
            [19473], [29984], [9961], [30242], [32117]
        ],
        # 8x8
        [
            [31548], [1549], [10130], [16656], [18591], [26308], [32537], [5403], 
            [18096], [30003], [16384], [16384], [16384]
        ]
    ],
    # qctx = 1
    [
        # 4x4
        [
            [30371], [7570], [13155], [20751], [20969], [27067], [32013], [5495], 
            [17942], [28280], [16384], [16384], [16384]
        ],
        # 8x8
        [
            [31782], [1836], [10689], [17604], [21622], [27518], [32399], [4419], 
            [16294], [28345], [16384], [16384], [16384]
        ],
    ],
    # qctx = 2
    [
        # 4x4
        [
            [29614], [9068], [12924], [19538], [17737], [24619], [30642], [4119], 
            [16026], [25657], [16384], [16384], [16384]
        ],
        # 8x8
        [
            [31957], [3230], [11153], [18123], [20143], [26536], [31986], [3050], 
            [14603], [25155], [16384], [16384], [16384]
        ],
    ],
    # qctx = 3
    [
        # 4x4
        [
            [26887], [6729], [10361], [17442], [15045], [22478], [29072], [2713], 
            [11861], [20773], [16384], [16384], [16384]
        ],
        # 8x8
        [
            [31903], [2044], [7528], [14618], [16182], [24168], [31037], [2786], 
            [11194], [20155], [16384], [16384], [16384]
        ],
    ]
]

TX_TYPE_CDF = [6554, 13107, 19661, 26214]

EOB_CLASS_16_CDF = [
    # qctx = 0
    [
        [840, 1039, 1980, 4895],  # Luma
        [3247, 4950, 9688, 14563]  # Chroma
    ],
    # qctx = 1
    [
        [2125, 2551, 5165, 8946],
        [7637, 9498, 14259, 19108]
    ],
    # qctx = 2
    [
        [4016, 4897, 8881, 14968],
        [11139, 13270, 18241, 23566]
    ],
    # qctx = 3
    [
        [6708, 8958, 14746, 22133],
        [19575, 21766, 26044, 29709]
    ]
]

EOB_CLASS_64_CDF = [
    # qctx = 0
    [
        [329, 498, 1101, 1784, 3265, 7758],  # Y
        [3505, 5304, 10086, 13814, 17684, 23370]  # U/V
    ],
    # qctx = 1
    [
        [1260, 1446, 2253, 3712, 6652, 13369],
        [8609, 10612, 14624, 18714, 22614, 29024]
    ],
    # qctx = 2
    [
        [2374, 2772, 4583, 7276, 12288, 19706],
        [15050, 17126, 21410, 24886, 28156, 30726]
    ],
    # qctx = 3
    [
        [6307, 7541, 12060, 16358, 22553, 27865],
        [24212, 25708, 28268, 30035, 31307, 32049]
    ]
]

EOB_EXTRA_4X4_CDF = [
    # qctx = 0
    [
        # Y
        [
            [16961],
            [17223],
            [7621],
        ],
        # U/V
        [
            [19069],
            [22525],
            [13377],
        ]
    ],
    # qctx = 1
    [
        # Y
        [
            [17471],
            [20223],
            [11357],
        ],
        # U/V
        [
            [20335],
            [21667],
            [14818],
        ]
    ],
    # qctx = 2
    [
        # Y
        [
            [18983],
            [20512],
            [14885],
        ],
        # U/V
        [
            [20090],
            [19444],
            [17286],
        ]
    ],
    # qctx = 3
    [
        # Y
        [
            [20177],
            [20789],
            [20262],
        ],
        # U/V
        [
            [21416],
            [20855],
            [23410],
        ]
    ],
]

EOB_EXTRA_8X8_CDF = [
    # qctx = 0
    [
        # Y
        [
            [20401],
            [17025],
            [12845],
            [12873],
            [14094],
        ],
        # U/V
        [
            [20681],
            [20701],
            [15250],
            [15017],
            [14928],
        ]
    ],
    # qctx = 1
    [
        # Y
        [
            [20430],
            [20662],
            [15367],
            [16970],
            [14657],
        ],
        # U/V
        [
            [22117],
            [22028],
            [18650],
            [16042],
            [15885],
        ]
    ],
    # qctx = 2
    [
        # Y
        [
            [19139],
            [21487],
            [18959],
            [20910],
            [19089],
        ],
        # U/V
        [
            [20536],
            [20664],
            [20625],
            [19123],
            [14862],
        ]
    ],
    # qctx = 3
    [
        # Y
        [
            [20238],
            [21057],
            [19159],
            [22337],
            [20159],
        ],
        # U/V
        [
            [20125],
            [20559],
            [21707],
            [22296],
            [17333],
        ]
    ],
]

COEFF_BASE_EOB_CDF = [
    # qctx = 0
    [
        # 4x4
        [
            # Y
            [
                [17837, 29055],
                [29600, 31446],
                [30844, 31878],
                [24926, 28948]
            ],
            # U/V
            [
                [21365, 30026],
                [30512, 32423],
                [31658, 32621],
                [29630, 31881]
            ]
        ],
        # 8x8
        [
            # Y
            [
                [5717, 26477],
                [30491, 31703],
                [31550, 32158],
                [29648, 31491]
            ],
            # U/V
            [
                [12608, 27820],
                [30680, 32225],
                [30809, 32335],
                [31299, 32423]
            ]
        ]
    ],
    # qctx = 1
    [
        # 4x4
        [
            # Y
            [
                [17560, 29888],
                [29671, 31549],
                [31007, 32056],
                [27286, 30006]
            ],
            # U/V
            [
                [26594, 31212],
                [31208, 32582],
                [31835, 32637],
                [30595, 32206]
            ]
        ],
        # 8x8
        [
            # Y
            [
                [15239, 29932],
                [31315, 32095],
                [32130, 32434],
                [30864, 31996]
            ],
            # U/V
            [
                [26279, 30968],
                [31142, 32495],
                [31713, 32540],
                [31929, 32594]
            ]
        ]
    ],
    # qctx = 2
    [
        # 4x4
        [
            # Y
            [
                [20092, 30774],
                [30695, 32020],
                [31131, 32103],
                [28666, 30870]
            ],
            # U/V
            [
                [27258, 31095],
                [31804, 32623],
                [31763, 32528],
                [31438, 32506]
            ]
        ],
        # 8x8
        [
            # Y
            [
                [18049, 30489],
                [31706, 32286],
                [32163, 32473],
                [31550, 32184]
            ],
            # U/V
            [
                [27116, 30842],
                [31971, 32598],
                [32088, 32576],
                [32067, 32664]
            ]
        ]
    ],
    # qctx = 3
    [
        # 4x4
        [
            # Y
            [
                [22497, 31198],
                [31715, 32495],
                [31606, 32337],
                [30388, 31990]
            ],
            # U/V
            [
                [27877, 31584],
                [32170, 32728],
                [32155, 32688],
                [32219, 32702]
            ]
        ],
        # 8x8
        [
            # Y
            [
                [21457, 31043],
                [31951, 32483],
                [32153, 32562],
                [31473, 32215]
            ],
            # U/V
            [
                [27558, 31151],
                [32020, 32640],
                [32097, 32575],
                [32242, 32719]
            ]
        ]
    ]
]

COEFF_BASE_CDF = [
    # qctx = 0
    [
        # 4x4
        [
            # Y
            [
                [4034, 8930, 12727],
                [18082, 29741, 31877],
                [12596, 26124, 30493],
                [9446, 21118, 27005],
                [6308, 15141, 21279],
                [2463, 6357, 9783],
                [20667, 30546, 31929],
                [13043, 26123, 30134],
                [8151, 18757, 24778],
                [5255, 12839, 18632],
                [2820, 7206, 11161],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [15736, 27553, 30604],
                [11210, 23794, 28787],
                [5947, 13874, 19701],
                [4215, 9323, 13891],
                [2833, 6462, 10059]
            ],
            # U/V
            [
                [6302, 16444, 21761],
                [23040, 31538, 32475],
                [15196, 28452, 31496],
                [10020, 22946, 28514],
                [6533, 16862, 23501],
                [3538, 9816, 15076],
                [24444, 31875, 32525],
                [15881, 28924, 31635],
                [9922, 22873, 28466],
                [6527, 16966, 23691],
                [4114, 11303, 17220],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [20201, 30770, 32209],
                [14754, 28071, 31258],
                [8378, 20186, 26517],
                [5916, 15299, 21978],
                [4268, 11583, 17901]
            ],
        ],
        # 8x8
        [
            # Y
            [
                [4536, 10072, 14001],
                [25459, 31416, 32206],
                [16605, 28048, 30818],
                [11008, 22857, 27719],
                [6915, 16268, 22315],
                [2625, 6812, 10537],
                [24257, 31788, 32499],
                [16880, 29454, 31879],
                [11958, 25054, 29778],
                [7916, 18718, 25084],
                [3383, 8777, 13446],
                [22720, 31603, 32393],
                [14960, 28125, 31335],
                [9731, 22210, 27928],
                [6304, 15832, 22277],
                [2910, 7818, 12166],
                [20375, 30627, 32131],
                [13904, 27284, 30887],
                [9368, 21558, 27144],
                [5937, 14966, 21119],
                [2667, 7225, 11319],
                [23970, 31470, 32378],
                [17173, 29734, 32018],
                [12795, 25441, 29965],
                [8981, 19680, 25893],
                [4728, 11372, 16902]
            ],
            # U/V
            [
                [6037, 16771, 21957],
                [24774, 31704, 32426],
                [16830, 28589, 31056],
                [10602, 22828, 27760],
                [6733, 16829, 23071],
                [3250, 8914, 13556],
                [25582, 32220, 32668],
                [18659, 30342, 32223],
                [12546, 26149, 30515],
                [8420, 20451, 26801],
                [4636, 12420, 18344],
                [27581, 32362, 32639],
                [18987, 30083, 31978],
                [11327, 24248, 29084],
                [7264, 17719, 24120],
                [3995, 10768, 16169],
                [25893, 31831, 32487],
                [16577, 28587, 31379],
                [10189, 22748, 28182],
                [6832, 17094, 23556],
                [3708, 10110, 15334],
                [25904, 32282, 32656],
                [19721, 30792, 32276],
                [12819, 26243, 30411],
                [8572, 20614, 26891],
                [5364, 14059, 20467]
            ],
        ],
    ],
    # qctx = 1
    [
        # 4x4
        [
            # Y
            [
                [6041, 11854, 15927],
                [20326, 30905, 32251],
                [14164, 26831, 30725],
                [9760, 20647, 26585],
                [6416, 14953, 21219],
                [2966, 7151, 10891],
                [23567, 31374, 32254],
                [14978, 27416, 30946],
                [9434, 20225, 26254],
                [6658, 14558, 20535],
                [3916, 8677, 12989],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [18088, 29545, 31587],
                [13062, 25843, 30073],
                [8940, 16827, 22251],
                [7654, 13220, 17973],
                [5733, 10316, 14456]
            ],
            # U/V
            [
                [8455, 19003, 24368],
                [23563, 32021, 32604],
                [16237, 29446, 31935],
                [10724, 23999, 29358],
                [6725, 17528, 24416],
                [3927, 10927, 16825],
                [26313, 32288, 32634],
                [17430, 30095, 32095],
                [11116, 24606, 29679],
                [7195, 18384, 25269],
                [4726, 12852, 19315],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [22822, 31648, 32483],
                [16724, 29633, 31929],
                [10261, 23033, 28725],
                [7029, 17840, 24528],
                [4867, 13886, 21502]
            ],
        ],
        # 8x8
        [
            # Y
            [
                [6779, 13743, 17678],
                [24806, 31797, 32457],
                [17616, 29047, 31372],
                [11063, 23175, 28003],
                [6521, 16110, 22324],
                [2764, 7504, 11654],
                [25266, 32367, 32637],
                [19054, 30553, 32175],
                [12139, 25212, 29807],
                [7311, 18162, 24704],
                [3397, 9164, 14074],
                [25988, 32208, 32522],
                [16253, 28912, 31526],
                [9151, 21387, 27372],
                [5688, 14915, 21496],
                [2717, 7627, 12004],
                [23144, 31855, 32443],
                [16070, 28491, 31325],
                [8702, 20467, 26517],
                [5243, 13956, 20367],
                [2621, 7335, 11567],
                [26636, 32340, 32630],
                [19990, 31050, 32341],
                [13243, 26105, 30315],
                [8588, 19521, 25918],
                [4717, 11585, 17304]
            ],
            # U/V
            [
                [8639, 19339, 24429],
                [24404, 31837, 32525],
                [16997, 29425, 31784],
                [11253, 24234, 29149],
                [6751, 17394, 24028],
                [3490, 9830, 15191],
                [26283, 32471, 32714],
                [19599, 31168, 32442],
                [13146, 26954, 30893],
                [8214, 20588, 26890],
                [4699, 13081, 19300],
                [28212, 32458, 32669],
                [18594, 30316, 32100],
                [11219, 24408, 29234],
                [6865, 17656, 24149],
                [3678, 10362, 16006],
                [25825, 32136, 32616],
                [17313, 29853, 32021],
                [11197, 24471, 29472],
                [6947, 17781, 24405],
                [3768, 10660, 16261],
                [27352, 32500, 32706],
                [20850, 31468, 32469],
                [14021, 27707, 31133],
                [8964, 21748, 27838],
                [5437, 14665, 21187]
            ],
        ],
    ],
    # qctx = 2
    [
        # 4x4
        [
            # Y
            [
                [8896, 16227, 20630],
                [23629, 31782, 32527],
                [15173, 27755, 31321],
                [10158, 21233, 27382],
                [6420, 14857, 21558],
                [3269, 8155, 12646],
                [24835, 32009, 32496],
                [16509, 28421, 31579],
                [10957, 21514, 27418],
                [7881, 15930, 22096],
                [5388, 10960, 15918],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [20745, 30773, 32093],
                [15200, 27221, 30861],
                [13032, 20873, 25667],
                [12285, 18663, 23494],
                [11563, 17481, 21489]
            ],
            # U/V
            [
                [10808, 22056, 26896],
                [25739, 32313, 32676],
                [17288, 30203, 32221],
                [11359, 24878, 29896],
                [6949, 17767, 24893],
                [4287, 11796, 18071],
                [27880, 32521, 32705],
                [19038, 31004, 32414],
                [12564, 26345, 30768],
                [8269, 19947, 26779],
                [5674, 14657, 21674],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [25742, 32319, 32671],
                [19557, 31164, 32454],
                [13381, 26381, 30755],
                [10101, 21466, 26722],
                [9209, 19650, 26825]
            ],
        ],
        # 8x8
        [
            # Y
            [
                [9704, 17294, 21132],
                [26762, 32278, 32633],
                [18382, 29620, 31819],
                [10891, 23475, 28723],
                [6358, 16583, 23309],
                [3248, 9118, 14141],
                [27204, 32573, 32699],
                [19818, 30824, 32329],
                [11772, 25120, 30041],
                [6995, 18033, 25039],
                [3752, 10442, 16098],
                [27222, 32256, 32559],
                [15356, 28399, 31475],
                [8821, 20635, 27057],
                [5511, 14404, 21239],
                [2935, 8222, 13051],
                [24875, 32120, 32529],
                [15233, 28265, 31445],
                [8605, 20570, 26932],
                [5431, 14413, 21196],
                [2994, 8341, 13223],
                [28201, 32604, 32700],
                [21041, 31446, 32456],
                [13221, 26213, 30475],
                [8255, 19385, 26037],
                [4930, 12585, 18830]
            ],
            # U/V
            [
                [11016, 22111, 26794],
                [25946, 32357, 32677],
                [17890, 30452, 32252],
                [11678, 25142, 29816],
                [6720, 17534, 24584],
                [4230, 11665, 17820],
                [28400, 32623, 32747],
                [21164, 31668, 32575],
                [13572, 27388, 31182],
                [8234, 20750, 27358],
                [5065, 14055, 20897],
                [28981, 32547, 32705],
                [18681, 30543, 32239],
                [10919, 24075, 29286],
                [6431, 17199, 24077],
                [3819, 10464, 16618],
                [26870, 32467, 32693],
                [19041, 30831, 32347],
                [11794, 25211, 30016],
                [6888, 18019, 24970],
                [4370, 12363, 18992],
                [29578, 32670, 32744],
                [23159, 32007, 32613],
                [15315, 28669, 31676],
                [9298, 22607, 28782],
                [6144, 15913, 22968]
            ],
        ],
    ],
    # qctx = 3
    [
        # 4x4
        [
            # Y
            [
                [7062, 16472, 22319],
                [24538, 32261, 32674],
                [13675, 28041, 31779],
                [8590, 20674, 27631],
                [5685, 14675, 22013],
                [3655, 9898, 15731],
                [26493, 32418, 32658],
                [16376, 29342, 32090],
                [10594, 22649, 28970],
                [8176, 17170, 24303],
                [5605, 12694, 19139],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [23888, 31902, 32542],
                [18612, 29687, 31987],
                [16245, 24852, 29249],
                [15765, 22608, 27559],
                [19895, 24699, 27510]
            ],
            # U/V
            [
                [9320, 22102, 27840],
                [27057, 32464, 32724],
                [16331, 30268, 32309],
                [10319, 23935, 29720],
                [6189, 16448, 24106],
                [3589, 10884, 18808],
                [29026, 32624, 32748],
                [19226, 31507, 32587],
                [12692, 26921, 31203],
                [7049, 19532, 27635],
                [7727, 15669, 23252],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [8192, 16384, 24576],
                [28056, 32625, 32748],
                [22383, 32075, 32669],
                [15417, 27098, 31749],
                [18127, 26493, 27190],
                [5461, 16384, 21845]
            ],
        ],
        # 8x8
        [
            # Y
            [
                [7754, 16948, 22142],
                [25670, 32330, 32691],
                [15663, 29225, 31994],
                [9878, 23288, 29158],
                [6419, 17088, 24336],
                [3859, 11003, 17039],
                [27562, 32595, 32725],
                [17575, 30588, 32399],
                [10819, 24838, 30309],
                [7124, 18686, 25916],
                [4479, 12688, 19340],
                [28385, 32476, 32673],
                [15306, 29005, 31938],
                [8937, 21615, 28322],
                [5982, 15603, 22786],
                [3620, 10267, 16136],
                [27280, 32464, 32667],
                [15607, 29160, 32004],
                [9091, 22135, 28740],
                [6232, 16632, 24020],
                [4047, 11377, 17672],
                [29220, 32630, 32718],
                [19650, 31220, 32462],
                [13050, 26312, 30827],
                [9228, 20870, 27468],
                [6146, 15149, 21971]
            ],
            # U/V
            [
                [8626, 20271, 26216],
                [26707, 32406, 32711],
                [16999, 30329, 32286],
                [11445, 25123, 30286],
                [6411, 18828, 25601],
                [6801, 12458, 20248],
                [29918, 32682, 32748],
                [20649, 31739, 32618],
                [12879, 27773, 31581],
                [7896, 21751, 28244],
                [5260, 14870, 23698],
                [29252, 32593, 32731],
                [17072, 30460, 32294],
                [10653, 24143, 29365],
                [6536, 17490, 23983],
                [4929, 13170, 20085],
                [28137, 32518, 32715],
                [18171, 30784, 32407],
                [11437, 25436, 30459],
                [7252, 18534, 26176],
                [4126, 13353, 20978],
                [31162, 32726, 32748],
                [23017, 32222, 32701],
                [15629, 29233, 32046],
                [9387, 22621, 29480],
                [6922, 17616, 25010]
            ]
        ]
    ]
]

COEFF_BR_CDF = [
    # qctx = 0
    [
        # 4x4
        [
            # Y
            [
                [14298, 20718, 24174],
                [12536, 19601, 23789],
                [8712, 15051, 19503],
                [6170, 11327, 15434],
                [4742, 8926, 12538],
                [3803, 7317, 10546],
                [1696, 3317, 4871],
                [14392, 19951, 22756],
                [15978, 23218, 26818],
                [12187, 19474, 23889],
                [9176, 15640, 20259],
                [7068, 12655, 17028],
                [5656, 10442, 14472],
                [2580, 4992, 7244],
                [12136, 18049, 21426],
                [13784, 20721, 24481],
                [10836, 17621, 21900],
                [8372, 14444, 18847],
                [6523, 11779, 16000],
                [5337, 9898, 13760],
                [3034, 5860, 8462]
            ],
            # U/V
            [
                [15967, 22905, 26286],
                [13534, 20654, 24579],
                [9504, 16092, 20535],
                [6975, 12568, 16903],
                [5364, 10091, 14020],
                [4357, 8370, 11857],
                [2506, 4934, 7218],
                [23032, 28815, 30936],
                [19540, 26704, 29719],
                [15158, 22969, 27097],
                [11408, 18865, 23650],
                [8885, 15448, 20250],
                [7108, 12853, 17416],
                [4231, 8041, 11480],
                [19823, 26490, 29156],
                [18890, 25929, 28932],
                [15660, 23491, 27433],
                [12147, 19776, 24488],
                [9728, 16774, 21649],
                [7919, 14277, 19066],
                [5440, 10170, 14185]
            ],
        ],
        # 8x8
        [
            # Y
            [
                [14406, 20862, 24414],
                [11824, 18907, 23109],
                [8257, 14393, 18803],
                [5860, 10747, 14778],
                [4475, 8486, 11984],
                [3606, 6954, 10043],
                [1736, 3410, 5048],
                [14430, 20046, 22882],
                [15593, 22899, 26709],
                [12102, 19368, 23811],
                [9059, 15584, 20262],
                [6999, 12603, 17048],
                [5684, 10497, 14553],
                [2822, 5438, 7862],
                [15785, 21585, 24359],
                [18347, 25229, 28266],
                [14974, 22487, 26389],
                [11423, 18681, 23271],
                [8863, 15350, 20008],
                [7153, 12852, 17278],
                [3707, 7036, 9982]
            ],
            # U/V
            [
                [15460, 21696, 25469],
                [12170, 19249, 23191],
                [8723, 15027, 19332],
                [6428, 11704, 15874],
                [4922, 9292, 13052],
                [4139, 7695, 11010],
                [2291, 4508, 6598],
                [19856, 26920, 29828],
                [17923, 25289, 28792],
                [14278, 21968, 26297],
                [10910, 18136, 22950],
                [8423, 14815, 19627],
                [6771, 12283, 16774],
                [4074, 7750, 11081],
                [19852, 26074, 28672],
                [19371, 26110, 28989],
                [16265, 23873, 27663],
                [12758, 20378, 24952],
                [10095, 17098, 21961],
                [8250, 14628, 19451],
                [5205, 9745, 13622]
            ],
        ],
    ],
    # qctx = 1
    [
        # 4x4
        [
            # Y
            [
                [14995, 21341, 24749],
                [13158, 20289, 24601],
                [8941, 15326, 19876],
                [6297, 11541, 15807],
                [4817, 9029, 12776],
                [3731, 7273, 10627],
                [1847, 3617, 5354],
                [14472, 19659, 22343],
                [16806, 24162, 27533],
                [12900, 20404, 24713],
                [9411, 16112, 20797],
                [7056, 12697, 17148],
                [5544, 10339, 14460],
                [2954, 5704, 8319],
                [12464, 18071, 21354],
                [15482, 22528, 26034],
                [12070, 19269, 23624],
                [8953, 15406, 20106],
                [7027, 12730, 17220],
                [5887, 10913, 15140],
                [3793, 7278, 10447]
            ],
            # U/V
            [
                [15571, 22232, 25749],
                [14506, 21575, 25374],
                [10189, 17089, 21569],
                [7316, 13301, 17915],
                [5783, 10912, 15190],
                [4760, 9155, 13088],
                [2993, 5966, 8774],
                [23424, 28903, 30778],
                [20775, 27666, 30290],
                [16474, 24410, 28299],
                [12471, 20180, 24987],
                [9410, 16487, 21439],
                [7536, 13614, 18529],
                [5048, 9586, 13549],
                [21090, 27290, 29756],
                [20796, 27402, 30026],
                [17819, 25485, 28969],
                [13860, 21909, 26462],
                [11002, 18494, 23529],
                [8953, 15929, 20897],
                [6448, 11918, 16454]
            ],
        ],
        # 8x8
        [
            # Y
            [
                [15999, 22208, 25449],
                [13050, 19988, 24122],
                [8594, 14864, 19378],
                [6033, 11079, 15238],
                [4554, 8683, 12347],
                [3672, 7139, 10337],
                [1900, 3771, 5576],
                [15788, 21340, 23949],
                [16825, 24235, 27758],
                [12873, 20402, 24810],
                [9590, 16363, 21094],
                [7352, 13209, 17733],
                [5960, 10989, 15184],
                [3232, 6234, 9007],
                [15761, 20716, 23224],
                [19318, 25989, 28759],
                [15529, 23094, 26929],
                [11662, 18989, 23641],
                [8955, 15568, 20366],
                [7281, 13106, 17708],
                [4248, 8059, 11440]
            ],
            # U/V
            [
                [14899, 21217, 24503],
                [13519, 20283, 24047],
                [9429, 15966, 20365],
                [6700, 12355, 16652],
                [5088, 9704, 13716],
                [4243, 8154, 11731],
                [2702, 5364, 7861],
                [22745, 28388, 30454],
                [20235, 27146, 29922],
                [15896, 23715, 27637],
                [11840, 19350, 24131],
                [9122, 15932, 20880],
                [7488, 13581, 18362],
                [5114, 9568, 13370],
                [20845, 26553, 28932],
                [20981, 27372, 29884],
                [17781, 25335, 28785],
                [13760, 21708, 26297],
                [10975, 18415, 23365],
                [9045, 15789, 20686],
                [6130, 11199, 15423]
            ],
        ],
    ],
    # qctx = 2
    [
        # 4x4
        [
            # Y
            [
                [16138, 22223, 25509],
                [15347, 22430, 26332],
                [9614, 16736, 21332],
                [6600, 12275, 16907],
                [4811, 9424, 13547],
                [3748, 7809, 11420],
                [2254, 4587, 6890],
                [15196, 20284, 23177],
                [18317, 25469, 28451],
                [13918, 21651, 25842],
                [10052, 17150, 21995],
                [7499, 13630, 18587],
                [6158, 11417, 16003],
                [4014, 7785, 11252],
                [15048, 21067, 24384],
                [18202, 25346, 28553],
                [14302, 22019, 26356],
                [10839, 18139, 23166],
                [8715, 15744, 20806],
                [7536, 13576, 18544],
                [5413, 10335, 14498]
            ],
            # U/V
            [
                [17394, 24501, 27895],
                [15889, 23420, 27185],
                [11561, 19133, 23870],
                [8285, 14812, 19844],
                [6496, 12043, 16550],
                [4771, 9574, 13677],
                [3603, 6830, 10144],
                [21656, 27704, 30200],
                [21324, 27915, 30511],
                [17327, 25336, 28997],
                [13417, 21381, 26033],
                [10132, 17425, 22338],
                [8580, 15016, 19633],
                [5694, 11477, 16411],
                [24116, 29780, 31450],
                [23853, 29695, 31591],
                [20085, 27614, 30428],
                [15326, 24335, 28575],
                [11814, 19472, 24810],
                [10221, 18611, 24767],
                [7689, 14558, 20321]
            ],
        ],
        # 8x8
        [
            # Y
            [
                [16214, 22380, 25770],
                [14213, 21304, 25295],
                [9213, 15823, 20455],
                [6395, 11758, 16139],
                [4779, 9187, 13066],
                [3821, 7501, 10953],
                [2293, 4567, 6795],
                [15859, 21283, 23820],
                [18404, 25602, 28726],
                [14325, 21980, 26206],
                [10669, 17937, 22720],
                [8297, 14642, 19447],
                [6746, 12389, 16893],
                [4324, 8251, 11770],
                [16532, 21631, 24475],
                [20667, 27150, 29668],
                [16728, 24510, 28175],
                [12861, 20645, 25332],
                [10076, 17361, 22417],
                [8395, 14940, 19963],
                [5731, 10683, 14912]
            ],
            # U/V
            [
                [14433, 21155, 24938],
                [14658, 21716, 25545],
                [9923, 16824, 21557],
                [6982, 13052, 17721],
                [5419, 10503, 15050],
                [4852, 9162, 13014],
                [3271, 6395, 9630],
                [22210, 27833, 30109],
                [20750, 27368, 29821],
                [16894, 24828, 28573],
                [13247, 21276, 25757],
                [10038, 17265, 22563],
                [8587, 14947, 20327],
                [5645, 11371, 15252],
                [22027, 27526, 29714],
                [23098, 29146, 31221],
                [19886, 27341, 30272],
                [15609, 23747, 28046],
                [11993, 20065, 24939],
                [9637, 18267, 23671],
                [7625, 13801, 19144]
            ],
        ],
    ],
    # qctx = 3
    [
        # 4x4
        [
            # Y
            [
                [18315, 24289, 27551],
                [16854, 24068, 27835],
                [10140, 17927, 23173],
                [6722, 12982, 18267],
                [4661, 9826, 14706],
                [3832, 8165, 12294],
                [2795, 6098, 9245],
                [17145, 23326, 26672],
                [20733, 27680, 30308],
                [16032, 24461, 28546],
                [11653, 20093, 25081],
                [9290, 16429, 22086],
                [7796, 14598, 19982],
                [6502, 12378, 17441],
                [21681, 27732, 30320],
                [22389, 29044, 31261],
                [19027, 26731, 30087],
                [14739, 23755, 28624],
                [11358, 20778, 25511],
                [10995, 18073, 24190],
                [9162, 14990, 20617]
            ],
            # U/V
            [
                [21425, 27952, 30388],
                [18062, 25838, 29034],
                [11956, 19881, 24808],
                [7718, 15000, 20980],
                [5702, 11254, 16143],
                [4898, 9088, 16864],
                [3679, 6776, 11907],
                [23294, 30160, 31663],
                [24397, 29896, 31836],
                [19245, 27128, 30593],
                [13202, 19825, 26404],
                [11578, 19297, 23957],
                [8073, 13297, 21370],
                [5461, 10923, 19745],
                [27367, 30521, 31934],
                [24904, 30671, 31940],
                [23075, 28460, 31299],
                [14400, 23658, 30417],
                [13885, 23882, 28325],
                [14746, 22938, 27853],
                [5461, 16384, 27307]
            ],
        ],
        # 8x8
        [
            # Y
            [
                [18274, 24813, 27890],
                [15537, 23149, 27003],
                [9449, 16740, 21827],
                [6700, 12498, 17261],
                [4988, 9866, 14198],
                [4236, 8147, 11902],
                [2867, 5860, 8654],
                [17124, 23171, 26101],
                [20396, 27477, 30148],
                [16573, 24629, 28492],
                [12749, 20846, 25674],
                [10233, 17878, 22818],
                [8525, 15332, 20363],
                [6283, 11632, 16255],
                [20466, 26511, 29286],
                [23059, 29174, 31191],
                [19481, 27263, 30241],
                [15458, 23631, 28137],
                [12416, 20608, 25693],
                [10261, 18011, 23261],
                [8016, 14655, 19666]
            ],
            # U/V
            [
                [17616, 24586, 28112],
                [15809, 23299, 27155],
                [10767, 18890, 23793],
                [7727, 14255, 18865],
                [6129, 11926, 16882],
                [4482, 9704, 14861],
                [3277, 7452, 11522],
                [22956, 28551, 30730],
                [22724, 28937, 30961],
                [18467, 26324, 29580],
                [13234, 20713, 25649],
                [11181, 17592, 22481],
                [8291, 18358, 24576],
                [7568, 11881, 14984],
                [24948, 29001, 31147],
                [25674, 30619, 32151],
                [20841, 26793, 29603],
                [14669, 24356, 28666],
                [11334, 23593, 28219],
                [8922, 14762, 22873],
                [8301, 13544, 20535]
            ]
        ]
    ]
]

DC_SIGN_CDF = [
    # qctx = 0
    [
        # Y
        [
            [128 * 125],
            [128 * 102],
            [128 * 147],
        ],
        # U/V
        [
            [128 * 119],
            [128 * 101],
            [128 * 135],
        ]
    ],
    # qctx = 1
    [
        # Y
        [
            [128 * 125],
            [128 * 102],
            [128 * 147],
        ],
        # U/V
        [
            [128 * 119],
            [128 * 101],
            [128 * 135],
        ]
    ],
    # qctx = 2
    [
        # Y
        [
            [128 * 125],
            [128 * 102],
            [128 * 147],
        ],
        # U/V
        [
            [128 * 119],
            [128 * 101],
            [128 * 135],
        ]
    ],
    # qctx = 3
    [
        # Y
        [
            [128 * 125],
            [128 * 102],
            [128 * 147],
        ],
        # U/V
        [
            [128 * 119],
            [128 * 101],
            [128 * 135],
        ]
    ],
]

# ============================================================================
# entropycode.py - src/entropycode.rs
# ============================================================================

class EntropyWriter:
    
    def __init__(self):
        """src/entropycode.rs:23"""
        self.data = bytearray()
        self.low = 0
        self.range = 0x8000
        self.count = -9
    
    # Sometimes we need to propagate a carry into the existing bytes
    # This function handles the core loop of that operation
    # Note: This assumes that the incoming carry is always 1, as it should
    # never be any other value.
    def _propagate_carry(self) -> None:
        """src/entropycode.rs:36"""
        for i in range(len(self.data) - 1, -1, -1):
            if self.data[i] == 255:
                # Carry continues to propagate
                self.data[i] = 0
                continue
            else:
                # Carry stops here
                self.data[i] += 1
                return
        # If we get here, the carry tried to propagate beyond the first byte
        # of the buffer, which should not be possible.
        raise RuntimeError("Carry propagated too far in entropy encoder")
    
    # Write an entropy-coded symbol using the given CDF
    # This does not yet implement CDF adaptation, so that must be turned off in the sequence header
    #
    # Note: Each CDF contains two implicit values:
    # * cdf[-1] = 0, so that when symbol == 0 "lo" is implicitly 0
    # * cdf[num_symbols - 1] = 32768, so that the probabilities sum to 1
    #
    # We do not store these values in the cdf array, and instead handle these cases
    # with ifs in this function
    def write_symbol(self, symbol: int, cdf: List[int]) -> None:
        """src/entropycode.rs:62"""
        symbol = int(symbol)
        num_symbols = len(cdf) + 1
        inv_hi = 0 if symbol == num_symbols - 1 else 32768 - cdf[symbol]
        
        # Update range to include new symbol
        if symbol == 0:
            # inv_lo = 32768 implicitly
            self.range -= ((self.range >> 8) * (inv_hi >> 6) >> 1) + 4 * (num_symbols - 1)
        else:
            inv_lo = 32768 - cdf[symbol - 1]
            
            u = ((self.range >> 8) * (inv_lo >> 6) >> 1) + 4 * (num_symbols - symbol)
            v = ((self.range >> 8) * (inv_hi >> 6) >> 1) + 4 * (num_symbols - symbol - 1)
            self.low += self.range - u
            self.range = u - v
        
        # Emit bytes if needed to normalize range
        d = 15 - floor_log2(self.range)
        s = self.count + d
        
        if s >= 40:
            num_bytes_ready = (s >> 3) + 1
            c = self.count + 24 - (num_bytes_ready << 3)
            
            output = self.low >> c
            self.low = self.low & ((1 << c) - 1)
            
            carry = output & (1 << (num_bytes_ready << 3))
            output = output & ((1 << (num_bytes_ready << 3)) - 1)
            
            # Propagate carry backwards into existing data
            if carry != 0:
                self._propagate_carry()
            
            # Then append new bytes to output
            write_be_bytes(self.data, output, num_bytes_ready)
            
            s = c + d - 24
        
        self.low <<= d
        self.range <<= d
        self.count = s

    # Helper function: Write a single bit symbol, without needing extra syntax fluff to convert
    # from a single probability to a CDF
    # Note that, due to the way CDFs are encoded, the specified probability is the probability
    # of this bit being zero
    def write_bit(self, value: int, p_zero: int):
        """src/entropycode.rs:113"""
        assert value == 0 or value == 1
        self.write_symbol(value, [p_zero])
    
    # Helper function: Write a flag which is logically a boolean
    # This is just syntactic sugar over self.write_bit(), mapping false => 0 and true => 1
    def write_bool(self, value: bool, p_false: int):
        """src/entropycode.rs:120"""
        self.write_symbol(1 if value else 0, [p_false])
    
    # Write an N-bit literal value. This means N bits, which are encoded
    # in high-to-low order with each bit having a 50:50 probability distribution
    def write_literal(self, value: int, nbits: int):
        """src/entropycode.rs:126"""
        assert nbits <= 32
        assert nbits == 32 or value < (1 << nbits)
        for shift in range(nbits - 1, -1, -1):
            bit = (value >> shift) & 1
            self.write_bit(bit, 16384)
    
    # Encode a given value using a Golomb code
    def write_golomb(self, value: int):
        """src/entropycode.rs:136"""
        # Because the "standard" Golomb code cannot represent 0, we actually Golomb-code `value + 1`
        value += 1
        
        length = int(value).bit_length() - 1
        # Write `length` zero bits, then the full value, including the leading 1 bit
        # (which acts as a delimiter, allowing the decoder to figure out the correct length)
        self.write_literal(0, length)
        self.write_literal(value, length + 1)
    
    # Finalize entropy block and return the generated bytes.
    # This takes care of two important requirements specified by AV1:
    # 1) The encoder must output enough extra bits to ensure that the decoder can
    #    unambiguously recover the correct value of all symbols
    # 2) There must be a trailing 1 bit at the end of each entropy coded block.
    #    Note that, if this is the last entropy coded block in a TILE_GROUP or FRAME OBU,
    #    then this also serves as the mandatory trailing 1 bit at the end of any OBU's content.
    def finalize(self) -> bytes:
        """src/entropycode.rs:155"""
        s = self.count + 10
        m = 0x3FFF
        
        # Inject a 1 bit in the right place
        e = ((self.low + m) & ~m) | (m + 1)
        n = (1 << (self.count + 16)) - 1
        
        # TODO: I think this can be simplified into a single round of
        # propagate_carry() + write_be_bytes(), but need to check that we won't overflow
        # any intermediate values
        while s > 0:
            val = e >> (self.count + 16)
            
            # Propagate carry backwards into existing data
            if (val & 0x100) != 0:
                self._propagate_carry()
            
            # Add new byte
            self.data.append(val & 0xFF)
            
            e = e & n
            s -= 8
            self.count -= 8
            n >>= 8
        
        # Pull out and return entropy coded data, but drop the rest of `self`
        return bytes(self.data)

# ============================================================================
# txfm.py - src/txfm.rs
# ============================================================================

def cospi_arr(cos_bit):
    """src/txfm.rs:16"""
    assert 10 <= cos_bit <= 13
    return av1_cospi_arr_data[cos_bit - 10]

def clamp_value(value, range_bits):
    """src/txfm.rs:21"""
    assert 0 < range_bits <= 32
    
    # When range_bits == 32, the intermediate value 1 << (range_bits - 1) doesn't fit into
    # a 32-bit int, so we need to use 64-bit. But the final values of min_ and max_ *will*
    # fit into a 32-bit int.
    min_val = -(1 << (range_bits - 1))
    max_val = (1 << (range_bits - 1)) - 1
    return clamp(value, min_val, max_val)

def clamp_array(arr, bits):
    """src/txfm.rs:33"""
    for i in range(len(arr)):
        arr[i] = clamp_value(arr[i], bits)

# Divide elements of an array by 2^bits, with rounding
# bits is allowed to be negative, in which case the values are scaled up
def round_shift_array(arr, bits):
    """src/txfm.rs:41"""
    if bits == 0:
        return
    elif bits < 0:
        shift = -bits
        for i in range(len(arr)):
            tmp = arr[i] << shift
            # Clamp to 32-bit signed integer range
            arr[i] = clamp(tmp, -(1 << 31), (1 << 31) - 1)
    else:
        for i in range(len(arr)):
            arr[i] = round2(arr[i], bits)

# Calculate round2(w0 * in0 + w1 * in1, cos_bit)
# In theory this "should" require the intermediates to be converted to `i64`s,
# but per a helpful comment from a certain someone ( ;) ) in libaom, we can
# in fact use wrapping 32-bit arithmetic throughout. We just have to explicitly
# inline the round2() operation so that that can use wrapping too.
def half_btf(w0, in0, w1, in1, cos_bit):
    """src/txfm.rs:63"""
    tmp = w0 * in0 + w1 * in1
    tmp &= 0xFFFFFFFF
    if tmp & (1 << 31):
        tmp -= 1 << 32
    offset = 1 << (cos_bit - 1)
    return (tmp + offset) >> cos_bit

# In-place 4-point forward DCT
def fwd_dct4(arr, cos_bit, stage_range):
    """src/txfm.rs:70"""
    assert len(arr) == 4
    
    cospi = cospi_arr(cos_bit)
    
    stage1 = [
        arr[0] + arr[3],
        arr[1] + arr[2],
        -arr[2] + arr[1],
        -arr[3] + arr[0]
    ]
    
    stage2 = [
        half_btf(cospi[32], stage1[0], cospi[32], stage1[1], cos_bit),
        half_btf(-cospi[32], stage1[1], cospi[32], stage1[0], cos_bit),
        half_btf(cospi[48], stage1[2], cospi[16], stage1[3], cos_bit),
        half_btf(cospi[48], stage1[3], -cospi[16], stage1[2], cos_bit)
    ]
    
    stage3 = [
        stage2[0],
        stage2[2],
        stage2[1],
        stage2[3]
    ]
    
    arr[:] = stage3

# In-place 8-point forward DCT
def fwd_dct8(arr, cos_bit, stage_range):
    """src/txfm.rs:100"""
    assert len(arr) == 8
    
    cospi = cospi_arr(cos_bit)
    
    # TODO: Range checks

    stage1 = [
        arr[0] + arr[7],
        arr[1] + arr[6],
        arr[2] + arr[5],
        arr[3] + arr[4],
        -arr[4] + arr[3],
        -arr[5] + arr[2],
        -arr[6] + arr[1],
        -arr[7] + arr[0],
    ]
    
    stage2 = [
        stage1[0] + stage1[3],
        stage1[1] + stage1[2],
        -stage1[2] + stage1[1],
        -stage1[3] + stage1[0],
        stage1[4],
        half_btf(-cospi[32], stage1[5], cospi[32], stage1[6], cos_bit),
        half_btf(cospi[32], stage1[6], cospi[32], stage1[5], cos_bit),
        stage1[7],
    ]
    
    stage3 = [
        half_btf(cospi[32], stage2[0], cospi[32], stage2[1], cos_bit),
        half_btf(-cospi[32], stage2[1], cospi[32], stage2[0], cos_bit),
        half_btf(cospi[48], stage2[2], cospi[16], stage2[3], cos_bit),
        half_btf(cospi[48], stage2[3], -cospi[16], stage2[2], cos_bit),
        stage2[4] + stage2[5],
        -stage2[5] + stage2[4],
        -stage2[6] + stage2[7],
        stage2[7] + stage2[6],
    ]
    
    stage4 = [
        stage3[0],
        stage3[1],
        stage3[2],
        stage3[3],
        half_btf(cospi[56], stage3[4], cospi[8], stage3[7], cos_bit),
        half_btf(cospi[24], stage3[5], cospi[40], stage3[6], cos_bit),
        half_btf(cospi[24], stage3[6], -cospi[40], stage3[5], cos_bit),
        half_btf(cospi[56], stage3[7], -cospi[8], stage3[4], cos_bit),
    ]
    
    stage5 = [
        stage4[0],
        stage4[4],
        stage4[2],
        stage4[6],
        stage4[1],
        stage4[5],
        stage4[3],
        stage4[7],
    ]
    
    arr[:] = stage5

# In-place 4-point inverse DCT
def inv_dct4(arr, cos_bit, stage_range):
    """src/txfm.rs:166"""
    assert len(arr) == 4
    
    cospi = cospi_arr(cos_bit)
    
    # TODO: Range checks

    stage1 = [
        arr[0],
        arr[2],
        arr[1],
        arr[3]
    ]
    
    stage2 = [
        half_btf(cospi[32], stage1[0], cospi[32], stage1[1], cos_bit),
        half_btf(cospi[32], stage1[0], -cospi[32], stage1[1], cos_bit),
        half_btf(cospi[48], stage1[2], -cospi[16], stage1[3], cos_bit),
        half_btf(cospi[16], stage1[2], cospi[48], stage1[3], cos_bit)
    ]
    
    stage3 = [
        clamp_value(stage2[0] + stage2[3], stage_range[3]),
        clamp_value(stage2[1] + stage2[2], stage_range[3]),
        clamp_value(stage2[1] - stage2[2], stage_range[3]),
        clamp_value(stage2[0] - stage2[3], stage_range[3])
    ]
    
    arr[:] = stage3

# In-place 8-point inverse DCT
def inv_dct8(arr, cos_bit, stage_range):
    """src/txfm.rs:197"""
    assert len(arr) == 8
    
    cospi = cospi_arr(cos_bit)
    
    # TODO: Range checks

    stage1 = [
        arr[0],
        arr[4],
        arr[2],
        arr[6],
        arr[1],
        arr[5],
        arr[3],
        arr[7],
    ]
    
    stage2 = [
        stage1[0],
        stage1[1],
        stage1[2],
        stage1[3],
        half_btf(cospi[56], stage1[4], -cospi[8], stage1[7], cos_bit),
        half_btf(cospi[24], stage1[5], -cospi[40], stage1[6], cos_bit),
        half_btf(cospi[40], stage1[5], cospi[24], stage1[6], cos_bit),
        half_btf(cospi[8], stage1[4], cospi[56], stage1[7], cos_bit)
    ]
    
    stage3 = [
        half_btf(cospi[32], stage2[0], cospi[32], stage2[1], cos_bit),
        half_btf(cospi[32], stage2[0], -cospi[32], stage2[1], cos_bit),
        half_btf(cospi[48], stage2[2], -cospi[16], stage2[3], cos_bit),
        half_btf(cospi[16], stage2[2], cospi[48], stage2[3], cos_bit),
        clamp_value(stage2[4] + stage2[5], stage_range[3]),
        clamp_value(stage2[4] - stage2[5], stage_range[3]),
        clamp_value(-stage2[6] + stage2[7], stage_range[3]),
        clamp_value(stage2[6] + stage2[7], stage_range[3]),
    ]
    
    stage4 = [
        clamp_value(stage3[0] + stage3[3], stage_range[4]),
        clamp_value(stage3[1] + stage3[2], stage_range[4]),
        clamp_value(stage3[1] - stage3[2], stage_range[4]),
        clamp_value(stage3[0] - stage3[3], stage_range[4]),
        stage3[4],
        half_btf(-cospi[32], stage3[5], cospi[32], stage3[6], cos_bit),
        half_btf(cospi[32], stage3[5], cospi[32], stage3[6], cos_bit),
        stage3[7],
    ]
    
    stage5 = [
        clamp_value(stage4[0] + stage4[7], stage_range[5]),
        clamp_value(stage4[1] + stage4[6], stage_range[5]),
        clamp_value(stage4[2] + stage4[5], stage_range[5]),
        clamp_value(stage4[3] + stage4[4], stage_range[5]),
        clamp_value(stage4[3] - stage4[4], stage_range[5]),
        clamp_value(stage4[2] - stage4[5], stage_range[5]),
        clamp_value(stage4[1] - stage4[6], stage_range[5]),
        clamp_value(stage4[0] - stage4[7], stage_range[5]),
    ]
    
    arr[:] = stage5

# Perform a 2D forward transform composed of two 1D transforms
# R = row transform (applied first)
# C = col transform (applied second)
def fwd_txfm2d(residual, txh, txw):
    """src/txfm.rs:264"""
    assert residual.rows() == txh
    assert residual.cols() == txw
    
    if txh == 8 and txw == 8:
        txsz_idx = 1
        fwd_txfm = fwd_dct8
    elif txh == 4 and txw == 4:
        txsz_idx = 0
        fwd_txfm = fwd_dct4
    else:
        raise NotImplementedError("Only 4x4 and 8x8 transforms supported right now")
    
    cos_bit_col = 13  # For both 4x4 and 8x8 forward transforms, less for some other sizes
    cos_bit_row = 13  # For both 4x4 and 8x8 forward transforms, less for some other sizes
    
    bd = 8
    stages = av1_txfm_stages[txsz_idx]
    shift = av1_txfm_fwd_shift[txsz_idx]
    stage_ranges = av1_txfm_fwd_range_mult2[txsz_idx]
    
    stage_range_col = []
    stage_range_row = []
    
    for i in range(stages):
        stage_range_col.append(round2(stage_ranges[i], 1) + shift[0] + bd + 1)
    
    for i in range(stages):
        stage_range_row.append(
            round2(stage_ranges[stages - 1] + stage_ranges[i], 1) + 
            shift[0] + shift[1] + bd + 1
        )
    
    # Column transforms
    transposed = residual.transpose()
    for j in range(txw):
        col = transposed.get_row(j)
        round_shift_array(col, -shift[0])
        fwd_txfm(col, cos_bit_col, stage_range_col)
        round_shift_array(col, -shift[1])
        transposed.set_row(j, col)
    
    # Row transforms
    transposed.transpose_into(residual)
    for i in range(txh):
        row = residual.get_row(i)
        fwd_txfm(row, cos_bit_row, stage_range_row)
        round_shift_array(row, -shift[2])
        residual.set_row(i, row)

# Perform a 2D forward transform composed of two 1D transforms
# R = row transform (applied first)
# C = col transform (applied second)
def inv_txfm2d(residual, txh, txw):
    """src/txfm.rs:319"""
    assert residual.rows() == txh
    assert residual.cols() == txw
    
    if txh == 8 and txw == 8:
        txsz_idx = 1
        inv_txfm = inv_dct8
    elif txh == 4 and txw == 4:
        txsz_idx = 0
        inv_txfm = inv_dct4
    else:
        raise NotImplementedError("Only 4x4 and 8x8 transforms supported right now")
    
    cos_bit_col = 12  # For all inverse transform sizes
    cos_bit_row = 12  # For all inverse transform sizes
    
    bd = 8
    stages = av1_txfm_stages[txsz_idx]
    shift = av1_txfm_inv_shift[txsz_idx]
    # TODO: I think this is just all zeros?
    #let stage_ranges = &av1_txfm_inv_range_mult2[txsz_idx];

    stage_range_row = []
    stage_range_col = []
    
    for i in range(stages):
        stage_range_row.append(av1_txfm_inv_start_range[txsz_idx] + bd + 1)
    
    for i in range(stages):
        stage_range_col.append(av1_txfm_inv_start_range[txsz_idx] + shift[0] + bd + 1)
    
    # Row transforms
    for i in range(txh):
        row = residual.get_row(i)
        clamp_array(row, bd + 8)
        inv_txfm(row, cos_bit_col, stage_range_col)
        round_shift_array(row, -shift[0])
        residual.set_row(i, row)
    
    # Column transforms
    transposed = residual.transpose()
    for j in range(txw):
        col = transposed.get_row(j)
        clamp_array(col, max(bd + 6, 16))
        inv_txfm(col, cos_bit_row, stage_range_row)
        round_shift_array(col, -shift[1])
        transposed.set_row(j, col)
    
    transposed.transpose_into(residual)

# ============================================================================
# recon.py - src/recon.rs
# ============================================================================

# Predictions - only DC_PRED for now
def dc_predict(pixels, y0: int, x0: int, h: int, w: int):
    """src/recon.rs:18"""
    # For now, as we only ever use one tile, we can infer the haveLeft and haveAbove flags as:
    have_left = x0 > 0
    have_above = y0 > 0
    
    sum_val = 0
    count = 0
    
    # Sum above pixels if available
    if have_above:
        for j in range(w):
            sum_val += int(pixels[y0 - 1][x0 + j])
            count += 1
    
    # Sum left pixels if available
    if have_left:
        for i in range(h):
            sum_val += int(pixels[y0 + i][x0 - 1])
            count += 1

    if have_above and have_left:
        avg = (sum_val + (w + h) // 2) // (w + h)
    elif have_above:
        avg = (sum_val + w // 2) // w
    elif have_left:
        avg = (sum_val + h // 2) // h
    else:
        avg = 128
    
    pred = clamp(avg, 0, 255)
    
    for i in range(h):
        for j in range(w):
            pixels[y0 + i][x0 + j] = pred

# Transform pipeline:
# 2d forward transform -> quantize -> dequantize -> 2d inverse transform
# The logic here implements the "big picture" stuff, for individual transforms
# see txfm.rs

# Calculate the residual (forward-transformed difference) between a given source image
# and the corresponding prediction
def compute_residual(source, pred, y0: int, x0: int, h: int, w: int):
    """src/recon.rs:56"""
    
    residual = Array2D.new_with(
        h, w,
        lambda i, j: int(source[y0 + i][x0 + j]) - int(pred[y0 + i][x0 + j])
    )
    
    fwd_txfm2d(residual, h, w)
    
    return residual

# Quantize the coefficients in a given transform block
def quantize(residual, qindex: int):
    """src/recon.rs:69"""
    
    dc_q = qindex_to_dc_q[qindex]
    ac_q = qindex_to_ac_q[qindex]
    
    def quant_func(i, j, coeff):
        q = dc_q if (i == 0 and j == 0) else ac_q
        
        # Divide coeff by q, with rounding to nearest, halves toward 0
        # A smaller bias can even be used, essentially rounding values slightly
        # above half toward zero as well, to improve the average rate-distortion tradeoff -
        # see for example QuantizationContext in rav1e.
        # But here we take the simplest option.
        abs_val = abs(coeff)
        sign = 1 if coeff > 0 else (-1 if coeff < 0 else 0)
        
        quantized = (abs_val + (q - 1) // 2) // q
        return sign * quantized
    
    residual.map(quant_func)

def dequantize(residual, qindex: int):
    """src/recon.rs:86"""

    dc_q = qindex_to_dc_q[qindex]
    ac_q = qindex_to_ac_q[qindex]
    
    def dequant_func(i, j, coeff):
        q = dc_q if (i == 0 and j == 0) else ac_q
        
        # Simply scale the quantized coefficient by the appropriate Q
        return coeff * q
    
    residual.map(dequant_func)

# Apply a residual to a prediction (in recon) to generate a fully reconstructed block
# Note: This consumes the residual array, pass in a clone if you want to keep
# the original array intact
def apply_residual(recon, residual, y0: int, x0: int, h: int, w: int):
    """src/recon.rs:100"""

    inv_txfm2d(residual, h, w)
    
    # Add to prediction and clamp
    for i in range(h):
        for j in range(w):
            val = int(recon[y0 + i][x0 + j]) + residual[i][j]
            # Clamp to valid pixel range
            recon[y0 + i][x0 + j] = min(max(val, 0), 255)

# ============================================================================
# av1_encoder.py - src/av1_encoder.rs
# ============================================================================

# "Mode info" unit - a struct representing the state of a single 4x4 luma pixel unit.
# The values in here can be used as contexts when encoding later blocks
@dataclass
class ModeInfo:
    """src/av1_encoder.rs:43"""
    # "Level context" for each plane
    # This is the sum of absolute values of the coefficients in each block,
    # capped at 63, and is used as part of the context for coefficient sizes
    #
    # Note: As we don't use transform partitioning, this is never actually
    # used for luma in this encoder. But it is required for chroma.
    level_ctx: List[int]

    # Sign of the DC coefficient for each plane
    # This is stored differently to what the spec says: we store
    # -1 if the DC coefficient is negative, 0 if zero, 1 if positive.
    # This way, we can compare the number of nearby +ve and -ve DC coefficients by
    # simply summing this value over nearby blocks.
    dc_sign: List[int]
    
    @staticmethod
    def zeroed():
        return ModeInfo([0, 0, 0], [0, 0, 0])

# Top-level encoder state
class AV1Encoder:
    """src/av1_encoder.rs:26"""
    
    def __init__(self, y_crop_width: int, y_crop_height: int):
        """src/av1_encoder.rs:92"""
        # Check limits imposed by AV1
        assert 0 < y_crop_width <= 65536
        assert 0 < y_crop_height <= 65536
        
        # Always padded to a multiple of 8x8 luma pixels
        self.y_width = (y_crop_width + 7) // 8 * 8
        self.y_height = (y_crop_height + 7) // 8 * 8
        
        # UV sizes (4:2:0 subsampling)
        self.uv_crop_width = round2(y_crop_width, 1)
        self.uv_crop_height = round2(y_crop_height, 1)
        self.uv_width = self.y_width // 2
        self.uv_height = self.y_height // 2
        
        # Original luma image size
        self.y_crop_width = y_crop_width
        self.y_crop_height = y_crop_height
    
    def generate_sequence_header(self) -> bytes:
        """src/av1_encoder.rs:118"""
        w = BitWriter()
        
        
        w.write_bits(0, 3) # Main profile: 8 or 10 bits, YUV 4:2:0 or monochrome
        w.write_bit(1)     # Still picture
        w.write_bit(1)     # With simplified headers
        
        w.write_bits(31, 5) # Level = 31 (no level-based constraints)
        
        # Width and height encoding
        w.write_bits(15, 4) # 16 bits for width
        w.write_bits(15, 4) # 16 bits for height
        w.write_bits(self.y_crop_width - 1, 16)
        w.write_bits(self.y_crop_height - 1, 16)
        
        # Disable features we don't use
        # - 64x64 superblocks
        # - No filter-intra, intra-edge-filter
        # - No superres, CDEF, loop restoration
        w.write_bits(0, 6)
        
        # Color configuration
        w.write_bit(0) # 8 bits per pixel
        w.write_bit(0) # Not monochrome
        w.write_bit(0) # No color info
        w.write_bit(0) # TV color range
        w.write_bits(0, 2) # Unknown chroma sample position
        w.write_bit(0) # UV channels have shared delta-q
        
        w.write_bit(0) # No film grain
        
        # Sequence headers always appear in their own OBU, so always add a trailing 1 bit
        return w.finalize(True)
    
    def generate_frame_header(self, base_qindex: int, add_trailing_one_bit: bool) -> bytes:
        """src/av1_encoder.rs:155"""
        w = BitWriter()
        
        w.write_bit(1) # Disable CDF updates
        w.write_bit(0) # Disable screen content tools
        w.write_bit(0) # Render size = frame size
        
        # Tile info
        # We need to code a tiling mode, then two zero bits to select 1x1 tiling.
        # However, if the width or height is less than one superblock (ie, 64 pixels), the
        # corresponding flag is implicitly set to 0 and doesn't need to be signalled.
        # So we need to add these conditionally
        w.write_bit(1)  # Uniform tile mode - allows the cheapest signaling of 1x1 tile layout
        if self.y_width > 64:
            w.write_bit(0)  # 1 tile column
        if self.y_height > 64:
            w.write_bit(0)  # 1 tile row
        
        # Quantization
        w.write_bits(base_qindex, 8)
        w.write_bits(0, 3)  # No frame-level delta-qs (three bits: Y DC, UV DC, UV AC)
        w.write_bit(0)  # Don't use quantizer matrices
        w.write_bit(0)  # No segmentation
        w.write_bit(0)  # No superblock-level delta-q
        
        # Deblocking params (all zero/disabled)
        w.write_bits(0, 6)  # Strength 0
        w.write_bits(0, 6)  # Strength 1
        w.write_bits(0, 3)  # Sharpness
        w.write_bit(0)  # No per-ref delta-lf
        
        # Transforms
        w.write_bit(0)  # Always use largest TX size
        w.write_bit(1)  # Use reduced TX type selection
        
        # Frame header needs a trailing 1 bit if it's in a standalone FRAME_HEADER OBU, but *not*
        # if it's in an OBU_FRAME
        return w.finalize(add_trailing_one_bit)
    
    def encode_image(self, source: 'Frame', base_qindex: int) -> bytes:
        """src/av1_encoder.rs:197"""
        # Encode a single tile for now
        assert source.y().width() == self.y_width
        assert source.y().height() == self.y_height
        assert base_qindex != 0  # No lossless mode support
        
        # Create tile encoder
        mi_rows = self.y_height // 4
        mi_cols = self.y_width // 4

        data = [[None for _ in range(mi_cols)] for _ in range(mi_rows)]
        for i in range(mi_rows):
            for j in range(mi_cols):
                data[i][j] = ModeInfo.zeroed()
        mode_info = Array2D(mi_rows, mi_cols, data=data)

        tile = TileEncoder(
            encoder=self,
            base_qindex=base_qindex,
            mode_info=mode_info,
            source=source,
            recon=Frame(self.y_height, self.y_width),
        )
        
        tile.encode()
        return tile.bitstream.finalize()

# Mutable state used while encoding a single tile
class TileEncoder:
    """Mutable state for encoding a single tile (src/av1_encoder.rs:46)"""
    
    def __init__(self, encoder: AV1Encoder, base_qindex: int, 
                 mode_info: 'Array2D', source: 'Frame', recon: 'Frame'):
        """src/av1_encoder.rs:46"""
        self.encoder = encoder
        self.bitstream = EntropyWriter()
        self.base_qindex = base_qindex
        # Mode info per 4x4 luma pixel unit
        self.mode_info = mode_info
        # Source frame
        # This is the image we are trying to reproduce
        # This must be pre-padded to match encoder.y_{width/height}, not the crop size
        self.source = source
        # Reconstructed frame
        self.recon = recon
    
    def encode(self):
        """src/av1_encoder.rs:225"""
        mi_rows = self.mode_info.rows()
        mi_cols = self.mode_info.cols()
        sb_rows = (mi_rows + 15) // 16
        sb_cols = (mi_cols + 15) // 16
        
        for sb_row in range(sb_rows):
            for sb_col in range(sb_cols):
                self.encode_superblock(sb_row, sb_col)
    
    def encode_superblock(self, sb_row: int, sb_col: int):
        """src/av1_encoder.rs:238"""
        mi_row = sb_row * 16
        mi_col = sb_col * 16
        self.encode_partition(mi_row, mi_col, 64)
    
    def encode_partition(self, mi_row: int, mi_col: int, bsize: int):
        """src/av1_encoder.rs:244"""
        # Always split down to 8x8 blocks
        # For each partition symbol, the context depends on whether the above and/or left
        # blocks are partitioned to a size smaller than what we're currently considering.
        # For blocks at one of the frame edges, the missing neighbour is assumed to be
        # the maximum possible size.
        #
        # Because we always split down to the same size, this ends up implying that the
        # context is:
        #
        # Current partition is 8x8: context = 0
        # Otherwise:
        #   Top-left corner: context = 0
        #   Left edge: context = 1
        #   Top edge: context = 2
        #   Everywhere else: context = 3
        if bsize == 8:
            self.bitstream.write_symbol(0, PARTITION_8X8_CDF) # PARTITION_NONE
            self.encode_block(mi_row, mi_col, bsize)
        else:
            # Split down further
            mi_rows = self.mode_info.rows()
            mi_cols = self.mode_info.cols()
            
            sub_rows = 2 if (mi_row + bsize // 8) < mi_rows else 1
            sub_cols = 2 if (mi_col + bsize // 8) < mi_cols else 1
            
            above_ctx = 1 if mi_row > 0 else 0
            left_ctx = 1 if mi_col > 0 else 0
            ctx = 2 * left_ctx + above_ctx
            
            if bsize == 16:
                cdf = PARTITION_16X16_CDF[ctx]
            elif bsize == 32:
                cdf = PARTITION_32X32_CDF[ctx]
            elif bsize == 64:
                cdf = PARTITION_64X64_CDF[ctx]
            else:
                raise ValueError(f"Reached an unexpected partition size: {bsize}")
            
            if sub_rows > 1 and sub_cols > 1:
                # Normal case, all partitions are available
                # Always choose PARTITION_SPLIT
                self.bitstream.write_symbol(3, cdf)
            elif sub_cols > 1:
                # The bottom edge of the frame falls in the top half of this partition, so
                # we must split horizontally. The only useful choice is whether to split the
                # in-bounds part in half vertically.
                #
                # Thus we use a binary CDF to pick between PARTITION_HORZ (0) or PARTITION_SPLIT (1).
                # The probability of PARTITION_SPLIT is calculated by summing the probabilities
                # of the following options using the original CDF:
                p_split = (get_prob(Partition.VERT, cdf) +
                          get_prob(Partition.SPLIT, cdf) +
                          get_prob(Partition.HORZ_A, cdf) +
                          get_prob(Partition.VERT_A, cdf) +
                          get_prob(Partition.VERT_B, cdf) +
                          get_prob(Partition.VERT_4, cdf))
                self.bitstream.write_bit(1, 32768 - p_split)
            elif sub_rows > 1:
                # The right edge of the frame falls in the left half of this partition, so
                # we must split vertically. The only useful choice is whether to split the
                # in-bounds part in half horizontally.
                #
                # Thus we use a binary CDF to pick between PARTITION_VERT (0) or PARTITION_SPLIT (1).
                # The probability of PARTITION_SPLIT is calculated by summing the probabilities
                # of the following options using the original CDF:
                p_split = (get_prob(Partition.HORZ, cdf) +
                          get_prob(Partition.SPLIT, cdf) +
                          get_prob(Partition.HORZ_A, cdf) +
                          get_prob(Partition.HORZ_B, cdf) +
                          get_prob(Partition.VERT_A, cdf) +
                          get_prob(Partition.HORZ_4, cdf))
                self.bitstream.write_bit(1, 32768 - p_split)
            else:
                # The bottom-right corner of the frame falls in the top-left quadrant of this partition,
                # so PARTITION_SPLIT is forced. Therefore we don't need to signal anything.
                pass
            
            offset = bsize // 8
            for i in range(sub_rows):
                for j in range(sub_cols):
                    self.encode_partition(mi_row + i * offset, 
                                        mi_col + j * offset, 
                                        bsize // 2)
    
    def encode_block(self, mi_row: int, mi_col: int, bsize: int):
        """src/av1_encoder.rs:330"""
        assert bsize == 8
        
        # Allocate a ModeInfo struct to hold information about the current block
        this_mi = ModeInfo.zeroed()
        
        # For skip, the context depends on the above and left skip flags,
        # defaulting to false if those aren't present
        # As we always set skip = false, this context is always 0
        # skip = false
        self.bitstream.write_symbol(0, SKIP_CDF)
        
        # For intra_frame_y_mode, the context depends on the above and left Y modes,
        # defaulting to DC_PRED if those aren't present
        # As we always choose DC_PRED, this context is always 0
        # intra_frame_y_mode(context=0,0) = DC_PRED
        self.bitstream.write_symbol(0, Y_MODE_CDF)
        
        # For uv_mode, the context is simply y_mode combined with whether CFL is allowed
        # Here the y mode is always DC_PRED and CFL is always allowed for 8x8 blocks,
        # so we always end up with the same context
        # uv_mode(context=0, CFL allowed) = DC_PRED
        self.bitstream.write_symbol(0, UV_MODE_CDF)
        
        # Encode residuals for each plane
        for plane in range(3):
            subsampling = 1 if plane > 0 else 0
            y0 = (mi_row * 4) >> subsampling
            x0 = (mi_col * 4) >> subsampling
            h = bsize >> subsampling
            w = bsize >> subsampling
            
            dc_predict(self.recon.plane_mut(plane).pixels_mut(), y0, x0, h, w)
            residual = compute_residual(
                self.source.plane(plane).pixels(),
                self.recon.plane(plane).pixels(),
                y0, x0, h, w
            )
            
            quantize(residual, self.base_qindex)
            
            # Encode the quantized coefficients while we have them,
            # before we consume them to finalize the reconstructed image
            self.encode_coeffs(plane, mi_row, mi_col, bsize, this_mi, residual)
            
            dequantize(residual, self.base_qindex)
            apply_residual(self.recon.plane_mut(plane).pixels_mut(), 
                          residual, y0, x0, h, w)
        
        # Save mode info for this block
        self.mode_info.fill_region(mi_row, mi_col, bsize // 4, bsize // 4, this_mi)
    
    def encode_coeffs(self, plane: int, mi_row: int, mi_col: int, bsize: int,
                     this_mi: ModeInfo, coeffs: 'Array2D'):
        """Encode transform coefficients (src/av1_encoder.rs:382)"""
        assert bsize == 8
        
        # Make sure there are the right number of coefficients
        txsize = bsize // 2 if plane > 0 else bsize
        txs_ctx = 1 if txsize == 8 else 0
        num_coeffs = txsize * txsize

        assert coeffs.rows() == txsize
        assert coeffs.cols() == txsize
        
        scan = scan_order_2d[txs_ctx]
        qctx = get_qctx(self.base_qindex)
        ptype = 1 if plane > 0 else 0
        
        # Find the "end of block" location
        # This is one past the last nonzero coefficient, or 0 if all coeffs are zero
        eob = 0
        cul_level = 0 # "Cumulative level", gets stored into this_mi.level_ctx
        
        for c in range(num_coeffs):
            row, col = scan[c]
            coeff = coeffs[row][col]
            cul_level += abs(coeff)
            if coeff != 0:
                eob = c + 1
        
        this_mi.level_ctx[plane] = min(cul_level, 63)
        all_zero = (eob == 0)
        
        # The all_zero symbol has a complex dependency on the nearby transform coefficients.
        # For luma, there is a special case where this is short-circuited to 0 for max-size
        # transforms (ie, transform size == block size), so we can ignore the complex logic.
        # But for chroma it is mandatory.
        if plane == 0:
            all_zero_ctx = 0
        else:
            above = False
            left = False
            # In theory we need to scan all blocks above and left of the current block here
            # However, because all blocks are currently 8x8, there's always exactly one
            # block above and one block left
            if mi_row > 0:
                above_block = self.mode_info[mi_row - 1][mi_col]
                above = (above_block.level_ctx[plane] != 0 or 
                        above_block.dc_sign[plane] != 0)
            
            if mi_col > 0:
                left_block = self.mode_info[mi_row][mi_col - 1]
                left = (left_block.level_ctx[plane] != 0 or 
                       left_block.dc_sign[plane] != 0)
            
            all_zero_ctx = 7 + (1 if above else 0) + (1 if left else 0)
        
        self.bitstream.write_symbol(1 if all_zero else 0,
                                   ALL_ZERO_CDF[qctx][txs_ctx][all_zero_ctx])
        
        if all_zero:
            return
        
        # Transform type - only coded for luma
        # As we selected the reduced transform set in the frame header,
        # we end up looking at the TX_SET_INTRA_2 set, which consists of
        # { IDTX, DCT_DCT, ADST_ADST, ADST_DCT, DCT_ADST }, in that order.
        # We want DCT_DCT, so we want to encode index 1.
        if plane == 0:
            self.bitstream.write_symbol(1, TX_TYPE_CDF)  # DCT_DCT
        
        # Number of coefficients, encoded as a logarithmic class + value within that class
        # Here, the contexts are qindex, plane type, and (for 16x16 and smaller)
        # whether the selected transform type is 1D (last context = 1) or 2D
        # (last context = 0). We always choose DCT_DCT, which counts as a 2D transform
        #
        # The EOB is split into a class plus optional extra bits. Each class has the following range:
        # Class 0 => EOB = 1
        # Class 1 => EOB = 2
        # Class 2 => EOB = 3-4
        # Class 3 => EOB = 5-8
        # ...
        # up to a maximum class which depends on the transform size
        # For 4x4 the largest class is class 4 (EOB = 9-16), for 8x8 it's class 6 (EOB = 33-64)
        eob_class = ceil_log2(eob)
        eob_class_cdf = (EOB_CLASS_64_CDF[qctx][ptype] if plane == 0 
                        else EOB_CLASS_16_CDF[qctx][ptype])
        self.bitstream.write_symbol(eob_class, eob_class_cdf)
        
        if eob_class > 1:
            eob_class_low = (1 << (eob_class - 1)) + 1
            
            # EOB classes 2+ require extra bits
            # The first extra bit is coded with a special CDF, the rest are literal bits
            # Context = (qctx, tx size, ptype, eob_class - 2)
            # For 8x8 and luma, this gives:
            first_extra_bit_cdf = (EOB_EXTRA_8X8_CDF[qctx][ptype][eob_class - 2] 
                                  if plane == 0
                                  else EOB_EXTRA_4X4_CDF[qctx][ptype][eob_class - 2])
            
            eob_shift = eob_class - 2
            extra_bit = ((eob - eob_class_low) >> eob_shift) & 1
            self.bitstream.write_symbol(extra_bit, first_extra_bit_cdf)
            
            # Write any remaining bits as a literal
            # Note: The AV1 decoder spec gives a more detailed process here,
            # but it's just writing individual bits from high to low,
            # which is exactly what write_literal() does
            remainder = eob - eob_class_low - (extra_bit << eob_shift)
            remainder_bits = eob_class - 2
            self.bitstream.write_literal(remainder, remainder_bits)
        
        # Write "base range" for each coefficient, in high-to-low index order
        for c in range(eob - 1, -1, -1):
            # Split coefficient into absolute value and sign, as these are coded separately
            row, col = scan[c]
            coeff = coeffs[row][col]
            abs_value = unsigned_abs_(coeff)
            
            # Code coeff_base symbol, which can indicate values 0, 1, 2, or 3+
            if c == eob - 1:
                # Last nonzero coefficient, so we know this can't be zero
                # Therefore we use a separate set of CDFs and contexts
                base_eob_ctx = (0 if c == 0
                               else 1 if c <= num_coeffs // 8
                               else 2 if c <= num_coeffs // 4
                               else 3)
                coded_value = min(abs_value - 1, 2)
                self.bitstream.write_symbol(coded_value,
                    COEFF_BASE_EOB_CDF[qctx][txs_ctx][ptype][base_eob_ctx])
            else:
                # Context depends on the base values of coefficients below and to the right,
                # which have already been encoded
                base_ctx = self.get_coeff_base_ctx(coeffs, row, col, txsize, c)
                coded_value = min(abs_value, 3)
                self.bitstream.write_symbol(coded_value,
                    COEFF_BASE_CDF[qctx][txs_ctx][ptype][base_ctx])
            
            # If coeff_base is 3, we can encode up to 4 symbols to increment the
            # absolute value further. This can directly encode values up to 14,
            # or the value 15 for all larger coefficients, in which case the remainder
            # is Golomb encoded in a separate pass
            if abs_value > 2:
                # All four coeff_br symbols use the same context and CDF, so compute that first
                br_ctx = self.get_coeff_br_ctx(coeffs, row, col, txsize, c)
                level = 3
                
                for _ in range(4):
                    coeff_br = min(abs_value - level, 3)
                    self.bitstream.write_symbol(coeff_br,
                        COEFF_BR_CDF[qctx][txs_ctx][ptype][br_ctx])
                    level += coeff_br
                    if coeff_br < 3:
                        break
        
        # Code DC sign + golomb bits
        dc_coeff = coeffs[0][0]
        if dc_coeff != 0:
            # The DC sign context depends on whether there are more +ve signs, more -ve signs,
            # or an equal number, among all above and left 4x4 units. Since we always use 8x8
            # blocks, there is exactly one above and one left neighbour.
            #
            # Also, for the chroma planes, in theory we're only meant to look at the blocks which are "chroma references",
            # i.e. the ones which contain an MI unit with odd mi_row and mi_col. This matters if we ever support 4x4
            # block sizes, but as we currently don't, that's just every block.
            #
            # Therefore we can simplify the scan given in the spec, into just looking at the single above and single left
            # block, if they exist.
            #
            # As we store the DC sign in ModeInfo::dc_sign as -1 / 0 / +1, we can do this by
            # simply summing the DC signs of all surrounding blocks
            net_neighbour_sign = 0
            if mi_row > 0:
                net_neighbour_sign += self.mode_info[mi_row - 1][mi_col].dc_sign[plane]
            if mi_col > 0:
                net_neighbour_sign += self.mode_info[mi_row][mi_col - 1].dc_sign[plane]
            
            # Map result to the appropriate context
            dc_sign_ctx = (0 if net_neighbour_sign == 0
                          else 1 if net_neighbour_sign < 0
                          else 2)
            
            sign = 1 if dc_coeff < 0 else 0
            self.bitstream.write_symbol(sign, DC_SIGN_CDF[qctx][ptype][dc_sign_ctx])
        
        if abs(dc_coeff) >= 15:
            self.bitstream.write_golomb(unsigned_abs_(dc_coeff) - 15)
        
        # Store DC sign for reference by later blocks
        this_mi.dc_sign[plane] = signum(dc_coeff)
        
        # Code sign + golomb bits for the rest of coefficients
        # Note that this is done in low-to-high index order, in contrast to the earlier loop
        for c in range(1, eob):
            row, col = scan[c]
            coeff = coeffs[row][col]
            
            if coeff != 0:
                sign = 1 if coeff < 0 else 0
                self.bitstream.write_literal(sign, 1)
            
            if abs(coeff) >= 15:
                self.bitstream.write_golomb(unsigned_abs_(coeff) - 15)
    
    def get_coeff_base_ctx(self, coeffs: 'Array2D', row: int, col: int, 
                          txsize: int, c: int) -> int:
        """src/av1_encoder.rs:533"""
        if c == 0:
            return 0
        
        mag = 0
        for row_off, col_off in Sig_Ref_Diff_Offset:
            ref_row = row + row_off
            ref_col = col + col_off
            if ref_row < txsize and ref_col < txsize:
                mag += min(abs(coeffs[ref_row][ref_col]), 3)
        
        mag_part = min(round2(mag, 1), 4)
        loc_part = Coeff_Base_Ctx_Offset_8x8[min(row, 4)][min(col, 4)]
        
        return mag_part + loc_part
    
    def get_coeff_br_ctx(self, coeffs: 'Array2D', row: int, col: int,
                        txsize: int, c: int) -> int:
        """src/av1_encoder.rs:559"""
        mag = 0
        
        for row_off, col_off in Mag_Ref_Offset:
            ref_row = row + row_off
            ref_col = col + col_off
            if ref_row < txsize and ref_col < txsize:
                mag += min(abs(coeffs[ref_row][ref_col]), 15)
        
        mag_part = min(round2(mag, 1), 6)
        
        if c == 0:
            loc_part = 0
        elif row < 2 and col < 2:
            loc_part = 7
        else:
            loc_part = 14
        
        return mag_part + loc_part

def get_qctx(base_qindex: int) -> int:
    if base_qindex <= 20:
        return 0
    elif base_qindex <= 60:
        return 1
    elif base_qindex <= 120:
        return 2
    else:
        return 3

# ============================================================================
# isobmff.py - src/isobmff.rs
# ============================================================================

class ISOBMFFWriter:
    """src/isobmff.rs:12"""
    
    def __init__(self):
        self.data = bytearray()
        self._box_stack = []
    
    def open_box(self, box_type: bytes) -> 'ISOBMFFBox':
        return ISOBMFFBox(self, box_type, version=None, flags=None)
    
    def open_box_with_version(self, box_type: bytes, version: int, flags: int) -> 'ISOBMFFBox':
        return ISOBMFFBox(self, box_type, version=version, flags=flags)
    
    def get_file_pos(self) -> int:
        return len(self.data)
    
    def write_u32_at_marker(self, pos: int, value: int) -> None:
        assert len(self.data) >= pos + 4
        struct.pack_into('>I', self.data, pos, value)
    
class ISOBMFFBox:
    """src/isobmff.rs:82"""
    
    def __init__(self, writer: ISOBMFFWriter, box_type: bytes, version: Optional[int], flags: Optional[int]):
        self.writer = writer
        self.size_pos = len(writer.data)
        
        # Write box header: 4 byte big-endian size, followed by 4-byte type
        assert len(box_type) == 4
        writer.data.extend(struct.pack('>I', 0))
        writer.data.extend(box_type)
        
        if version is not None:
            assert flags is not None
            assert flags < (1 << 24)
            writer.data.extend(struct.pack('>I', (version << 24) | flags))
    
    def __enter__(self):
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        cur_pos = len(self.writer.data)
        total_size = cur_pos - self.size_pos
        struct.pack_into('>I', self.writer.data, self.size_pos, total_size)
    
    def open_box(self, box_type: bytes) -> 'ISOBMFFBox':
        return ISOBMFFBox(self.writer, box_type, version=None, flags=None)
    
    def open_box_with_version(self, box_type: bytes, version: int, flags: int) -> 'ISOBMFFBox':
        return ISOBMFFBox(self.writer, box_type, version=version, flags=flags)
    
    def get_file_pos(self) -> int:
        return len(self.writer.data)
    
    def mark_u32(self) -> int:
        marker = len(self.writer.data)
        self.write_u32(0)
        return marker
    
    def write_u8(self, value: int) -> None:
        self.writer.data.extend(struct.pack('B', value))
    
    def write_u16(self, value: int) -> None:
        self.writer.data.extend(struct.pack('>H', value))
    
    def write_u32(self, value: int) -> None:
        self.writer.data.extend(struct.pack('>I', value))
    
    def write_bytes(self, data: bytes) -> None:
        self.writer.data.extend(data)

# ============================================================================
# hls.py - src/hls.rs
# ============================================================================

def pack_obus(sequence_header: bytes, frame_header: bytes, tile_data: bytes, 
              include_temporal_delimiter: bool = True) -> bytes:
    """src/hls.rs:13"""
    av1_data = bytearray()
    
    # Optionally include temporal delimiter
    # Reasoning:
    #
    # 1) The AV1 spec says that AV1 streams must begin with a temporal delimiter,
    #    even for still images. Accordingly, libaom will refuse to decode any .obu file
    #    which doesn't start with one, whether invoked via aomdec or ffmpeg.
    #
    # 2) The AVIF spec explicitly states that this is *not* required in still-image AVIF files,
    #    and libavif does not require one
    #
    # 3) However, when generating AVIF files, libavif *does* include a temporal delimiter,
    #    while ffmpeg doesn't
    #
    # The upshot is that this is mandatory for .obu files, and optional for .avif files
    if include_temporal_delimiter:
        av1_data.append(0b0001_0010) # Temporal delimiter OBU
        av1_data.append(0)           # with a zero-byte payload
    
    av1_data.append(0b0000_1010) # Sequence header OBU
    write_leb128(av1_data, len(sequence_header)) # Payload size
    av1_data.extend(sequence_header) # Payload
    
    av1_data.append(0b0011_0010) # Frame OBU: combined frame header + tile data
    write_leb128(av1_data, len(frame_header) + len(tile_data))
    av1_data.extend(frame_header)
    av1_data.extend(tile_data)
    
    return bytes(av1_data)

def pack_avif(av1_data: bytes, crop_width: int, crop_height: int,
              color_primaries: int = 2, transfer_function: int = 2, 
              matrix_coefficients: int = 2) -> bytes:
    """src/hls.rs:47"""
    avif = ISOBMFFWriter()
    
    # "File type" box
    with avif.open_box(b"ftyp") as ftyp:
        ftyp.write_bytes(b"avif") # Main file type
        ftyp.write_u32(0)         # AVIF version
        ftyp.write_bytes(b"avifmif1miafMA1B") # "Compatible brands"
    
    # Metadata box - contains the rest of the file header
    with avif.open_box_with_version(b"meta", 0, 0) as meta:
        # "Handler" box
        # Per libavif, this *must* be the first child of the "meta" box, and must have type "pict".
        # Other than that, this contains a few fields which must be zero, and the name of the encoder
        with meta.open_box_with_version(b"hdlr", 0, 0) as hdlr:
            hdlr.write_u32(0) # Must be zero
            hdlr.write_bytes(b"pict")
            hdlr.write_u32(0) # Must be zero
            hdlr.write_u32(0) # Must be zero
            hdlr.write_u32(0) # Must be zero
            hdlr.write_bytes(b"tinyavif\0")
        
        # "Primary item" box
        with meta.open_box_with_version(b"pitm", 0, 0) as pitm:
            pitm.write_u16(1) # Primary item is item number 1
        
        # "Item location" box
        with meta.open_box_with_version(b"iloc", 0, 0) as iloc:
            iloc.write_u8(0x44) # 4 bytes each for offset and length
            iloc.write_u8(0)    # No base offset; 4 reserved bits
            iloc.write_u16(1)   # One item
            
            iloc.write_u16(1)   # Item ID 1
            iloc.write_u16(0)   # "Data reference index" = 0
            iloc.write_u16(1)   # One extent
            # Allocate space for the content position, but we'll need to come back and fill it in later
            content_pos_marker = iloc.mark_u32()
            iloc.write_u32(len(av1_data))  # Content length
        
        # "Item info" box
        with meta.open_box_with_version(b"iinf", 0, 0) as iinf:
            iinf.write_u16(1) # One item
            with iinf.open_box_with_version(b"infe", 2, 0) as infe:
                infe.write_u16(1)             # Item index 1
                infe.write_u16(0)             # "Protection" = 0
                infe.write_bytes(b"av01")     # AV1 stream
                infe.write_bytes(b"Color\0")  # Main colour data, not, say, alpha data
        
        # "Image properties" box
        with meta.open_box(b"iprp") as iprp:
            # "Image property container" box
            with iprp.open_box(b"ipco") as ipco:
                # "Image spatial extent" box
                with ipco.open_box_with_version(b"ispe", 0, 0) as ispe:
                    ispe.write_u32(crop_width)
                    ispe.write_u32(crop_height)
                
                # "Pixel information" box
                with ipco.open_box_with_version(b"pixi", 0, 0) as pixi:
                    pixi.write_u8(3) # 3 channels
                    pixi.write_u8(8) # 8 bits per channel
                    pixi.write_u8(8)
                    pixi.write_u8(8)
                
                # AV1-specific info box
                with ipco.open_box(b"av1C") as av1c:
                    av1c.write_u8(0x81)       # Custom version field: 1 bit marker that must be 1 + 7-bit version = 1
                    av1c.write_u8(0x1F)       # Profile 0, level 31 (== unconstrained)
                    av1c.write_u8(0b00001100) # Main tier, 8bpp, not monochrome, 4:2:0 subsampling, chroma sample position unknown
                    av1c.write_u8(0x00)       # No presentation delay info
                
                # Color info
                with ipco.open_box(b"colr") as colr:
                    colr.write_bytes(b"nclx") # Required subtype
                    colr.write_u16(color_primaries)
                    colr.write_u16(transfer_function)
                    colr.write_u16(matrix_coefficients)
                    colr.write_u8(0) # TV color range (change to 0x80 for full-range)
            
            # "Image property mapping association" box
            with iprp.open_box_with_version(b"ipma", 0, 0) as ipma:
                ipma.write_u32(1) # One item
                
                ipma.write_u16(1) # Item ID 1
                ipma.write_u8(4)  # Four associations
                # Associations - 1 byte each
                # Each has a 1-bit flag (0x80 bit) indicating whether the association is mandatory,
                # and a 7-bit ID which presumably indexes into the 'ipco' table above
                ipma.write_u8(1)
                ipma.write_u8(2)
                ipma.write_u8(0x83)
                ipma.write_u8(4)
    
    # Finally, the 'mdat' box contains the image data itself
    with avif.open_box(b"mdat") as mdat:
        content_pos = mdat.get_file_pos()
        mdat.write_bytes(av1_data)
    
    avif.write_u32_at_marker(content_pos_marker, content_pos)
    
    return bytes(avif.data)
    
# ============================================================================
# array2d.py - src/array2d.rs
# ============================================================================

IndexType = Union[int, slice, tuple]

class Array2D:
    """Two-dimensional array type"""

    def __init__(self, rows: int, cols: int, data: Optional[list[list[Any]]] = None):
        self.rows_val = rows
        self.cols_val = cols
        self.stride = cols
        if data is None:
            self.data = [[0 for _ in range(cols)] for _ in range(rows)]
        else:
            assert len(data) == rows and all(len(row) == cols for row in data)

            if any(any(not isinstance(v, int) for v in row) for row in data):
                self.data = [list(row) for row in data]
            else:
                self.data = [[int(v) for v in row] for row in data]

    def get_row(self, index: int) -> List[int]:
        return self.data[index]

    def set_row(self, index: int, values: List[int]):
        self.data[index] = list(values)

    def rows(self) -> int:
        """src/array2d.rs:25"""
        return self.rows_val

    def cols(self) -> int:
        """src/array2d.rs:29"""
        return self.cols_val

    def fill_with(self, f: Callable[[int, int], int]):
        """src/array2d.rs:35"""
        for i in range(self.rows_val):
            for j in range(self.cols_val):
                self.data[i][j] = f(i, j)

    # Fill a region of a given size with (cloned) copies of `value`
    def fill_region(self, row_start: int, col_start: int, rows: int, cols: int, value):
        """src/array2d.rs:46"""
        row_end = row_start + rows
        col_end = col_start + cols
        
        if row_end > self.rows_val:
            raise ValueError(f"Array2D row indices out of bounds (index {row_start}..{row_end} vs. size {self.rows_val})")
        if col_end > self.cols_val:
            raise ValueError(f"Array2D column indices out of bounds (index {col_start}..{col_end} vs. size {self.cols_val})")
        
        for row in range(row_start, row_end):
            for col in range(col_start, col_end):
                # Due to the above checks, this calculation should never overflow
                self[row][col] = value

    @staticmethod
    def zeroed(rows: int, cols: int) -> 'Array2D':
        """src/array2d.rs:67"""
        return Array2D(rows, cols)
    
    @staticmethod
    def new_with(rows: int, cols: int, f) -> 'Array2D':
        """src/array2d.rs:81"""
        result = Array2D.zeroed(rows, cols)
        result.fill_with(f)
        return result

    def transpose_into(self, dst: 'Array2D'):
        """src/array2d.rs:89"""
        assert self.rows_val == dst.cols_val
        assert self.cols_val == dst.rows_val
        for i in range(self.cols_val):
            for j in range(self.rows_val):
                dst[i][j] = self[j][i]

    def transpose(self) -> 'Array2D':
        """src/array2d.rs:99"""
        dst = Array2D.zeroed(self.cols_val, self.rows_val)
        self.transpose_into(dst)
        return dst

    def map(self, f):
        """src/array2d.rs:105"""
        for i in range(self.rows_val):
            for j in range(self.cols_val):
                self.data[i][j] = f(i, j, self.data[i][j])

    def __getitem__(self, index: IndexType):
        return self.data[index]

    def __setitem__(self, index: IndexType, value):
        self.data[index] = value

# ============================================================================
# util.py - src/util.rs
# ============================================================================

# Write 0-8 bytes from a u64 value in big-endian order
def write_be_bytes(w, value: int, nbytes: int):
    """src/util.rs:15"""
    assert nbytes <= 8
    assert nbytes == 8 or (value >> (8 * nbytes)) == 0
    bytes_to_write = value.to_bytes(nbytes, byteorder='big')
    w.extend(bytes_to_write)

# Write a value in AV1's LEB128 format
# In this format, each byte provides 7 bits of the value,
# along with a flag bit which indicates whether there are more bytes to read
# Also, in contrast to everything else here, this value is little-endian
def write_leb128(w, value: int):
    """src/util.rs:29"""
    if value == 0:
        w.extend(bytes([0]))
        return
    while True:
        byte = value & 0x7F
        value >>= 7
        more = value != 0
        if more:
            byte |= 0x80
        w.extend(bytes([byte]))
        if not more:
            break

# Expose min/max as binary functions, rather than as methods
def min_func(a, b):
    """src/util.rs:43"""
    return min(a, b)

def max_func(a, b):
    """src/util.rs:47"""
    return max(a, b)

def clamp(v, lo, hi):
    """src/util.rs:51"""
    if v < lo:
        return lo
    elif v > hi:
        return hi
    else:
        return v

def round2(value: int, n: int) -> int:
    if n == 0:
        return value
    offset = (1 << n) >> 1
    return (value + offset) >> n

def abs_(value: int) -> int:
    return abs(value)

def unsigned_abs_(value: int) -> int:
    return abs(value)

def signum(value: int) -> int:
    if value > 0:
        return 1
    elif value < 0:
        return -1
    else:
        return 0

def round2_signed(value: int, n: int) -> int:
    if value < 0:
        return -round2(-value, n)
    else:
        return round2(value, n)

def floor_log2(value: int) -> int:
    if value == 0:
        raise ValueError("Cannot take log2(0)")
    return value.bit_length() - 1

def ceil_log2(value: int) -> int:
    if value == 0:
        raise ValueError("ceil_log2: Cannot take log2(0)")
    elif value == 1:
        return 0
    else:
        return (value - 1).bit_length()

# Extract the probability of a single symbol from a CDF
def get_prob(symbol: int, cdf: List[int]) -> int:
    """src/util.rs:297"""
    if symbol == 0:
        return cdf[0]
    elif symbol == len(cdf):
        # Account for the implicit extra element 32768 on the end of the CDF
        return 32768 - cdf[symbol - 1]
    else:
        return cdf[symbol] - cdf[symbol - 1]

# ============================================================================
# enums.py - src/enums.rs
# ============================================================================

class Partition:
    """src/enums.rs:10"""
    NONE = 0
    HORZ = 1
    VERT = 2
    SPLIT = 3
    HORZ_A = 4
    HORZ_B = 5
    VERT_A = 6
    VERT_B = 7
    HORZ_4 = 8
    VERT_4 = 9

# ============================================================================
# consts.py - src/consts.rs
# ============================================================================

PLANE_TYPES = 2

# Number of transform sizes that this code supports
# Currently only 2: 4x4 (for chroma) and 8x8 (for luma)
SUPPORTED_TX_SIZES = 2

# Maximum EOB class among the supported transforms
# This is class 6, indicating that the EOB is in [33, 64], for an 8x8 transform
MAX_SUPPORTED_EOB_CLASS = 6

# Values used in CDF sizes
TOKEN_CDF_Q_CTXS = 4

TXB_SKIP_CONTEXTS = 13

COEFF_BASE_CONTEXTS = 26 # for 2d transforms; there are a separate set of 16 contexts for 1d transforms
COEFF_BASE_EOB_CONTEXTS = 4
COEFF_BR_CONTEXTS = 21
DC_SIGN_CONTEXTS = 3

# Scan orders for 2D (ie. not H_* or V_*) transforms
# The input to this is an index in coefficient scan order,
# the output is an index (row * tx_width + col) into the quantized
# coefficient array
#
# Note: These values are translated from the spec, mapping N => (N / width, N % width)
# This is *different* to the tables in libaom, which are transposed for some reason.
# Correspondingly, the forward/inverse transforms in libaom have an extra
# transpose operation at the end/start (respectively) to fix the coefficient order.

# 4x4
default_scan_4x4 = [
    (0, 0), (0, 1), (1, 0), (2, 0), (1, 1), (0, 2), (0, 3), (1, 2),
    (2, 1), (3, 0), (3, 1), (2, 2), (1, 3), (2, 3), (3, 2), (3, 3)
]

# 8x8
default_scan_8x8 = [
    (0, 0), (0, 1), (1, 0), (2, 0), (1, 1), (0, 2), (0, 3), (1, 2),
    (2, 1), (3, 0), (4, 0), (3, 1), (2, 2), (1, 3), (0, 4), (0, 5),
    (1, 4), (2, 3), (3, 2), (4, 1), (5, 0), (6, 0), (5, 1), (4, 2),
    (3, 3), (2, 4), (1, 5), (0, 6), (0, 7), (1, 6), (2, 5), (3, 4),
    (4, 3), (5, 2), (6, 1), (7, 0), (7, 1), (6, 2), (5, 3), (4, 4),
    (3, 5), (2, 6), (1, 7), (2, 7), (3, 6), (4, 5), (5, 4), (6, 3),
    (7, 2), (7, 3), (6, 4), (5, 5), (4, 6), (3, 7), (4, 7), (5, 6),
    (6, 5), (7, 4), (7, 5), (6, 6), (5, 7), (6, 7), (7, 6), (7, 7)
]

scan_order_2d = [default_scan_4x4, default_scan_8x8]

# Offsets of coefficients which are looked at to determine
# the context for coeff_base
# We only store the offsets for DCT_DCT for now
Sig_Ref_Diff_Offset = [(0, 1), (1, 0), (1, 1), (0, 2), (2, 0)]
Mag_Ref_Offset = [(0, 1), (1, 0), (1, 1)]

Coeff_Base_Ctx_Offset_8x8 = [
    [0,  1,  6,  6,  21],
    [1,  6,  6,  21, 21],
    [6,  6,  21, 21, 21],
    [6,  21, 21, 21, 21],
    [21, 21, 21, 21, 21]
]

# av1_cospi_arr[i][j] = (int)round(cos(PI*j/128) * (1<<(cos_bit_min+i)));
av1_cospi_arr_data = [
    # cos_bit = 10
    # Unused currently (used in AV1 for some large transforms)
    [1024, 1024, 1023, 1021, 1019, 1016, 1013, 1009, 1004, 999, 993, 987, 980,
     972,  964,  955,  946,  936,  926,  915,  903,  891,  878, 865, 851, 837,
     822,  807,  792,  775,  759,  742,  724,  706,  688,  669, 650, 630, 610,
     590,  569,  548,  526,  505,  483,  460,  438,  415,  392, 369, 345, 321,
     297,  273,  249,  224,  200,  175,  150,  125,  100,  75,  50,  25],
    # cos_bit = 11
    # Unused currently (used in AV1 for some large transforms)
    [2048, 2047, 2046, 2042, 2038, 2033, 2026, 2018, 2009, 1998, 1987,
     1974, 1960, 1945, 1928, 1911, 1892, 1872, 1851, 1829, 1806, 1782,
     1757, 1730, 1703, 1674, 1645, 1615, 1583, 1551, 1517, 1483, 1448,
     1412, 1375, 1338, 1299, 1260, 1220, 1179, 1138, 1096, 1053, 1009,
     965,  921,  876,  830,  784,  737,  690,  642,  595,  546,  498,
     449,  400,  350,  301,  251,  201,  151,  100,  50],
    # cos_bit = 12
    # Used for all inverse transforms
    [4096, 4095, 4091, 4085, 4076, 4065, 4052, 4036, 4017, 3996, 3973,
     3948, 3920, 3889, 3857, 3822, 3784, 3745, 3703, 3659, 3612, 3564,
     3513, 3461, 3406, 3349, 3290, 3229, 3166, 3102, 3035, 2967, 2896,
     2824, 2751, 2675, 2598, 2520, 2440, 2359, 2276, 2191, 2106, 2019,
     1931, 1842, 1751, 1660, 1567, 1474, 1380, 1285, 1189, 1092, 995,
     897,  799,  700,  601,  501,  401,  301,  201,  101],
    # cos_bit = 13
    # Used for 4x4 and 8x8 forward transforms
    [8192, 8190, 8182, 8170, 8153, 8130, 8103, 8071, 8035, 7993, 7946,
     7895, 7839, 7779, 7713, 7643, 7568, 7489, 7405, 7317, 7225, 7128,
     7027, 6921, 6811, 6698, 6580, 6458, 6333, 6203, 6070, 5933, 5793,
     5649, 5501, 5351, 5197, 5040, 4880, 4717, 4551, 4383, 4212, 4038,
     3862, 3683, 3503, 3320, 3135, 2948, 2760, 2570, 2378, 2185, 1990,
     1795, 1598, 1401, 1202, 1003, 803,  603,  402,  201]
]

av1_txfm_stages = [4, 6]  # 4x4, 8x8

av1_txfm_fwd_shift = [[2, 0, 0], [2, -1, 0]] # 4x4, 8x8

# Maximum range of values after each forward transform stage,
# rounded up to powers of 2
av1_txfm_fwd_range_mult2 = [[0, 2, 3, 3, 0, 0], [0, 2, 4, 5, 5, 5]] # 4x4, 8x8

av1_txfm_inv_shift = [[0, -4], [-1, -4]] # 4x4, 8x8

av1_txfm_inv_start_range = [5, 6] # 4x4, 8x8

# DC and AC quantizers for a given qindex
qindex_to_dc_q = [
    4,    8,    8,    9,    10,  11,  12,  12,  13,  14,  15,   16,   17,   18,
    19,   19,   20,   21,   22,  23,  24,  25,  26,  26,  27,   28,   29,   30,
    31,   32,   32,   33,   34,  35,  36,  37,  38,  38,  39,   40,   41,   42,
    43,   43,   44,   45,   46,  47,  48,  48,  49,  50,  51,   52,   53,   53,
    54,   55,   56,   57,   57,  58,  59,  60,  61,  62,  62,   63,   64,   65,
    66,   66,   67,   68,   69,  70,  70,  71,  72,  73,  74,   74,   75,   76,
    77,   78,   78,   79,   80,  81,  81,  82,  83,  84,  85,   85,   87,   88,
    90,   92,   93,   95,   96,  98,  99,  101, 102, 104, 105,  107,  108,  110,
    111,  113,  114,  116,  117, 118, 120, 121, 123, 125, 127,  129,  131,  134,
    136,  138,  140,  142,  144, 146, 148, 150, 152, 154, 156,  158,  161,  164,
    166,  169,  172,  174,  177, 180, 182, 185, 187, 190, 192,  195,  199,  202,
    205,  208,  211,  214,  217, 220, 223, 226, 230, 233, 237,  240,  243,  247,
    250,  253,  257,  261,  265, 269, 272, 276, 280, 284, 288,  292,  296,  300,
    304,  309,  313,  317,  322, 326, 330, 335, 340, 344, 349,  354,  359,  364,
    369,  374,  379,  384,  389, 395, 400, 406, 411, 417, 423,  429,  435,  441,
    447,  454,  461,  467,  475, 482, 489, 497, 505, 513, 522,  530,  539,  549,
    559,  569,  579,  590,  602, 614, 626, 640, 654, 668, 684,  700,  717,  736,
    755,  775,  796,  819,  843, 869, 896, 925, 955, 988, 1022, 1058, 1098, 1139,
    1184, 1232, 1282, 1336
]

qindex_to_ac_q = [
    4,    8,    9,    10,   11,   12,   13,   14,   15,   16,   17,   18,   19,
    20,   21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
    33,   34,   35,   36,   37,   38,   39,   40,   41,   42,   43,   44,   45,
    46,   47,   48,   49,   50,   51,   52,   53,   54,   55,   56,   57,   58,
    59,   60,   61,   62,   63,   64,   65,   66,   67,   68,   69,   70,   71,
    72,   73,   74,   75,   76,   77,   78,   79,   80,   81,   82,   83,   84,
    85,   86,   87,   88,   89,   90,   91,   92,   93,   94,   95,   96,   97,
    98,   99,   100,  101,  102,  104,  106,  108,  110,  112,  114,  116,  118,
    120,  122,  124,  126,  128,  130,  132,  134,  136,  138,  140,  142,  144,
    146,  148,  150,  152,  155,  158,  161,  164,  167,  170,  173,  176,  179,
    182,  185,  188,  191,  194,  197,  200,  203,  207,  211,  215,  219,  223,
    227,  231,  235,  239,  243,  247,  251,  255,  260,  265,  270,  275,  280,
    285,  290,  295,  300,  305,  311,  317,  323,  329,  335,  341,  347,  353,
    359,  366,  373,  380,  387,  394,  401,  408,  416,  424,  432,  440,  448,
    456,  465,  474,  483,  492,  501,  510,  520,  530,  540,  550,  560,  571,
    582,  593,  604,  615,  627,  639,  651,  663,  676,  689,  702,  715,  729,
    743,  757,  771,  786,  801,  816,  832,  848,  864,  881,  898,  915,  933,
    951,  969,  988,  1007, 1026, 1046, 1066, 1087, 1108, 1129, 1151, 1173, 1196,
    1219, 1243, 1267, 1292, 1317, 1343, 1369, 1396, 1423, 1451, 1479, 1508, 1537,
    1567, 1597, 1628, 1660, 1692, 1725, 1759, 1793, 1828
]

# ============================================================================
# bitcode.py - src/bitcode.rs
# ============================================================================

class BitWriter:
    """src/bitcode.rs:15"""
    
    def __init__(self):
        """src/bitcode.rs:22"""
        self.data = bytearray()
        self.partial_byte = 0
        self.bitpos = 0
    
    def write_bit(self, bit: int):
        """src/bitcode.rs:30"""
        assert bit == 0 or bit == 1
        self.partial_byte = (self.partial_byte << 1) | bit
        self.bitpos += 1
        if self.bitpos % 8 == 0:
            self.data.extend(bytes([self.partial_byte]))
            self.partial_byte = 0
    
    # Helper function: Write a flag which is logically a boolean
    # This is just syntactic sugar over self.write_bit(), mapping false => 0 and true => 1
    def write_bool(self, flag: bool):
        """src/bitcode.rs:42"""
        self.write_bit(1 if flag else 0)
    
    def write_bits(self, bits: int, nbits: int):
        """src/bitcode.rs:46"""
        # Only allow up to 56 bits in a single write, to simplify some later logic
        assert nbits <= 56
        assert bits < (1 << nbits) if nbits < 64 else True
        
        # Pack the current pending bits + new bits into one 64-bit value
        # This will always fit because we require nbits <= 56 above
        partial_bits = self.bitpos % 8
        combined = ((self.partial_byte << nbits) | bits)
        combined_nbits = partial_bits + nbits
        
        # Then flush any
        full_bytes = combined_nbits // 8
        leftover_bits = combined_nbits % 8
        
        write_be_bytes(self.data, combined >> leftover_bits, full_bytes)
        self.partial_byte = combined & ((1 << leftover_bits) - 1)
        self.bitpos += nbits
    
    def byte_align(self):
        """src/bitcode.rs:64"""
        partial_bits = self.bitpos % 8
        if partial_bits == 0:
            # Already aligned
            return
        else:
            extra_bits = 8 - partial_bits
            self.data.extend(bytes([self.partial_byte << extra_bits]))
            self.partial_byte = 0
            self.bitpos += extra_bits
    
    # Finalize the bit buffer and return the generated bytes.
    # In AV1, all OBUs must finish with an extra '1' bit, followed by enough zero
    # bits to align us to a full byte. The `add_trailing_one_bit` argument can be used
    # to add this trailing bit automatically.
    def finalize(self, add_trailing_one_bit: bool) -> bytes:
        """src/bitcode.rs:81"""
        if add_trailing_one_bit:
            self.write_bit(1)
        self.byte_align()
        return bytes(self.data)

# ============================================================================
# frame.py - src/frame.rs
# ============================================================================

class Plane:
    """src/frame.rs:16"""
    
    def __init__(self, pixels: Array2D, crop_width: int, crop_height: int):
        # Pixel data
        # The width() / height() methods of this array give the padded size.
        # For the real size, use the .crop_width / .crop_height members below
        self.pixels_val = pixels
        self.crop_width_val = crop_width
        self.crop_height_val = crop_height
    
    def pixels(self) -> Array2D:
        """src/frame.rs:27"""
        return self.pixels_val
    
    def pixels_mut(self) -> Array2D:
        """src/frame.rs:31"""
        return self.pixels_val
    
    def width(self) -> int:
        """src/frame.rs:35"""
        return self.pixels_val.cols()
    
    def height(self) -> int:
        """src/frame.rs:39"""
        return self.pixels_val.rows()
    
    def crop_width(self) -> int:
        """src/frame.rs:43"""
        return self.crop_width_val
    
    def crop_height(self) -> int:
        """src/frame.rs:47"""
        return self.crop_height_val
    
    # Fill in the pixels outside the crop region, by copying the rightmost and
    # bottommost pixels from within the crop region
    # This *must* be called after any modification which may potentially affect
    # the last row/column of pixels, or which may disturb the padding region
    def fill_padding(self):
        """src/frame.rs:55"""
        crop_width = self.crop_width_val
        crop_height = self.crop_height_val
        width = self.width()
        height = self.height()
        
        for row in range(height):
            if row < crop_height:
                rightmost_pixel = self.pixels_val[row][crop_width - 1]
                for col in range(crop_width, width):
                    self.pixels_val[row][col] = rightmost_pixel
        
        for row in range(crop_height, height):
            for col in range(width):
                self.pixels_val[row][col] = self.pixels_val[crop_height - 1][col]
    
    def read_from(self, r: BinaryIO):
        """src/frame.rs:77"""
        for row in range(self.crop_height_val):
            data = r.read(self.crop_width_val)
            if len(data) != self.crop_width_val:
                raise IOError("Unexpected EOF")
            for col in range(self.crop_width_val):
                self.pixels_val[row][col] = data[col]
        self.fill_padding()
    
    def write_to(self, w: BinaryIO):
        """src/frame.rs:85"""
        for row in range(self.crop_height_val):
            row_data = bytes(self.pixels_val[row][:self.crop_width_val])
            w.write(row_data)

class Frame:
    """src/frame.rs:93"""
    
    def __init__(self, y_crop_height: int, y_crop_width: int):
        """src/frame.rs:98"""
        y_width = (y_crop_width + 7) // 8 * 8
        y_height = (y_crop_height + 7) // 8 * 8
        
        uv_crop_width = round2(y_crop_width, 1)
        uv_crop_height = round2(y_crop_height, 1)
        
        uv_width = y_width // 2
        uv_height = y_height // 2
        
        self.planes = [
            Plane(Array2D.zeroed(y_height, y_width), y_crop_width, y_crop_height),
            Plane(Array2D.zeroed(uv_height, uv_width), uv_crop_width, uv_crop_height),
            Plane(Array2D.zeroed(uv_height, uv_width), uv_crop_width, uv_crop_height),
        ]
    
    def plane(self, idx: int) -> Plane:
        """src/frame.rs:129"""
        return self.planes[idx]
    
    def plane_mut(self, idx: int) -> Plane:
        """src/frame.rs:133"""
        return self.planes[idx]
    
    def y(self) -> Plane:
        """src/frame.rs:137"""
        return self.planes[0]
    
    def y_mut(self) -> Plane:
        """src/frame.rs:141"""
        return self.planes[0]
    
    def u(self) -> Plane:
        """src/frame.rs:145"""
        return self.planes[1]
    
    def u_mut(self) -> Plane:
        """src/frame.rs:149"""
        return self.planes[1]
    
    def v(self) -> Plane:
        """src/frame.rs:153"""
        return self.planes[2]
    
    def v_mut(self) -> Plane:
        """src/frame.rs:157"""
        return self.planes[2]

# ============================================================================
# y4m.py - src/y4m.rs
# ============================================================================

Y4M_FILE_MAGIC = "YUV4MPEG2 "
Y4M_FRAME_MAGIC = "FRAME"

def read_decimal(r: BinaryIO) -> Tuple[int, int]:
    """src/y4m.rs:32"""
    v = 0
    while True:
        byte_data = r.read(1)
        if not byte_data:
            raise IOError("Unexpected EOF")
        byte = byte_data[0]
        if ord('0') <= byte <= ord('9'):
            v = 10 * v + (byte - ord('0'))
        else:
            # Non-digit, stop parsing
            # Return value and the character that wasn't part of this value
            return (v, byte)

# Read next character, expecting it to be whitespace
# Returns the character if it's whitespace, panics if not
def expect_whitespace(r: BinaryIO) -> int:
    """src/y4m.rs:51"""
    byte = r.read(1)[0]
    if byte in [ord(' '), ord('\t'), ord('\n')]:
        return byte
    else:
        raise ValueError(f"Unexpected byte {byte} in Y4M file")

# Skip forward until we find a whitespace character
# Returns the first whitespace character found
def find_whitespace(r: BinaryIO) -> int:
    """src/y4m.rs:65"""
    while True:
        byte = r.read(1)[0]
        if byte in [ord(' '), ord('\t'), ord('\n')]:
            return byte

class Y4MReader:
    """src/y4m.rs:20"""
    
    def __init__(self, inner: BinaryIO):
        """src/y4m.rs:80"""
        self.inner = inner
        
        # Read header line
        file_magic = inner.read(10)
        if file_magic != Y4M_FILE_MAGIC.encode():
            raise ValueError("Invalid file header")
        
        width = 0
        height = 0
        
        # Parse parameter line
        while True:
            byte = inner.read(1)[0]
            if byte == ord('\n'):
                # End of parameter line
                break
            elif byte in [ord(' '), ord('\t')]:
                # Skip whitespace
                continue
            elif byte == ord('W'):
                width, byte = read_decimal(inner)
                if byte == ord('\n'):
                    break
                elif byte in [ord(' '), ord('\t'), ord('\r')]:
                    continue
                else:
                    raise ValueError(f"Unexpected byte {byte} in Y4M file")
            elif byte == ord('H'):
                height, byte = read_decimal(inner)
                if byte == ord('\n'):
                    break
                elif byte in [ord(' '), ord('\t'), ord('\r')]:
                    continue
                else:
                    raise ValueError(f"Unexpected byte {byte} in Y4M file")
            else:
                if find_whitespace(inner) == ord('\n'):
                    # Other parameters that we aren't parsing yet
                    # Just skip until we find whitespace
                    break
        
        if width == 0 or height == 0:
            # Didn't find a width/height parameter, or it was zero
            raise ValueError(f"Invalid Y4M size {width}x{height}")
        
        self.width = width
        self.height = height
    
    def read_frame(self) -> Frame:
        """src/y4m.rs:142"""
        # Read frame line
        # Technically this can have parameters, but they aren't useful to us.
        # So just check the magic number to ensure we're in the right place
        # and skip the rest of the line
        frame_magic = self.inner.read(5)
        if frame_magic != Y4M_FRAME_MAGIC.encode():
            raise ValueError("Invalid frame header")
        
        while self.inner.read(1)[0] != ord('\n'):
            pass
        
        # Read actual frame data
        frame = Frame(self.height, self.width)
        frame.y_mut().read_from(self.inner)
        frame.u_mut().read_from(self.inner)
        frame.v_mut().read_from(self.inner)
        
        return frame

class Y4MWriter:
    """src/y4m.rs:26"""
    
    def __init__(self, inner: BinaryIO, width: int, height: int):
        """src/y4m.rs:166"""
        self.inner = inner
        self.width = width
        self.height = height
        
        inner.write(Y4M_FILE_MAGIC.encode())
        inner.write(f"W{width} H{height}\n".encode())
    
    def write_frame(self, frame: Frame):
        """src/y4m.rs:177"""
        assert frame.y().width() == self.width
        assert frame.y().height() == self.height
        
        self.inner.write(Y4M_FRAME_MAGIC.encode())
        self.inner.write(b'\n')
        frame.y().write_to(self.inner)
        frame.u().write_to(self.inner)
        frame.v().write_to(self.inner)

# ============================================================================
# main.py - src/main.rs
# ============================================================================

def main():
    """src/main.rs"""
    start_time = time.time()

    parser = argparse.ArgumentParser(
        description="TinyAVIF - Minimal AV1/AVIF encoder",
        usage="tinyavif <INPUT> [-o <OUTPUT>] [--qindex <QINDEX>]"
    )
    
    parser.add_argument("input", type=Path, help="Input file, must end in .y4m")
    parser.add_argument("-o", "--output", type=Path, help="Output file, must end in .obu or .avif [default: <input>.avif]")
    parser.add_argument("-q", "--qindex", type=int, default=35, help="Quantizer to use. Valid range is 1-255, inclusive")
    parser.add_argument("--color-primaries", type=int, default=2, help="Color primaries")
    parser.add_argument("--transfer-function", type=int, default=2, help="Transfer function") 
    parser.add_argument("--matrix-coefficients", type=int, default=2, help="Matrix coefficients")
    
    args = parser.parse_args()

    # Validate input file extension
    input_path = args.input
    if not input_path.suffix:
        print("Error: Input file must end in .y4m")
        return 2
    
    if input_path.suffix.lower() != ".y4m":
        print("Error: Input file must end in .y4m")
        return 2

    # Determine output path
    if args.output:
        output_path = args.output
    else:
        output_path = input_path.with_suffix(".avif")

    # Validate output file extension
    if not output_path.suffix:
        print("Error: Output file must end in .obu or .avif")
        return 2
    
    output_ext = output_path.suffix.lower()
    if output_ext not in [".obu", ".avif"]:
        print("Error: Output file must end in .obu or .avif")
        return 2

    # Validate qindex range
    base_qindex = args.qindex
    if not (1 <= base_qindex <= 255):
        print("Error: qindex must be in range 1-255, inclusive")
        return 2

    # Read Y4M file
    with open(input_path, 'rb') as f:
        y4m_reader = Y4MReader(f)
        source = y4m_reader.read_frame()

    # Get image dimensions
    crop_width = source.y().crop_width()
    crop_height = source.y().crop_height()
    padded_width = source.y().width()
    padded_height = source.y().height()

    # Check that the image will fit in one tile
    if padded_width > 4096 or padded_width * padded_height > 4096 * 2304:
        print(f"Error: image size {crop_width}x{crop_height} (padded to {padded_width}x{padded_height}) is too large to fit in a single tile")
        return 2

    # Generate AV1 data
    encoder = AV1Encoder(crop_width, crop_height)
    sequence_header = encoder.generate_sequence_header()
    frame_header = encoder.generate_frame_header(base_qindex, False)
    tile_data = encoder.encode_image(source, base_qindex)

    # Pack into higher-level structure
    av1_data = pack_obus(sequence_header, frame_header, tile_data, True)

    # Write output based on extension
    if output_ext == ".obu":
        # Write OBU data directly, with no further wrapping
        with open(output_path, 'wb') as f:
            f.write(av1_data)
    else:  # .avif
        # Wrap OBU data in an AVIF container
        avif_data = pack_avif(av1_data, crop_width, crop_height,
                                args.color_primaries, args.transfer_function,
                                args.matrix_coefficients)
        with open(output_path, 'wb') as f:
            f.write(avif_data)

    end_time = time.time()
    elapsed_time = end_time - start_time
    
    print(f"Generated {output_path} in {elapsed_time:.2f} seconds")
    return 0
    
if __name__ == "__main__":
    main()
