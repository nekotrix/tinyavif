// AV1-compatible bitwise reader/writer structs
// In AV1, bytes are written most-significant-bit-first

use crate::util::write_be_bytes;

pub struct BitWriter {
  data: Vec<u8>,
  partial_byte: u8,
  bitpos: usize
}

impl BitWriter {
  pub fn new() -> Self {
    Self {
      data: Vec::new(),
      partial_byte: 0u8,
      bitpos: 0
    }
  }

  pub fn write_bit(&mut self, bit: u8) {
    assert!(bit == 0 || bit == 1);
    self.partial_byte = (self.partial_byte << 1) | bit;
    self.bitpos += 1;
    if self.bitpos % 8 == 0 {
      self.data.push(self.partial_byte);
      self.partial_byte = 0u8;
    }
  }

  // Helper function: Write a flag which is logically a boolean
  // This is just syntactic sugar over self.write_bit(), mapping false => 0 and true => 1
  pub fn write_bool(&mut self, flag: bool) {
    self.write_bit(flag as u8);
  }

  pub fn write_bits(&mut self, bits: u64, nbits: usize) {
    // Only allow up to 56 bits in a single write, to simplify some later logic
    assert!(nbits <= 56);
    assert!(bits < (1u64 << nbits));

    // Pack the current pending bits + new bits into one 64-bit value
    // This will always fit because we require nbits <= 56 above
    let partial_bits = self.bitpos % 8;
    let combined = ((self.partial_byte as u64) << nbits) | bits;
    let combined_nbits = partial_bits + nbits;

    // Then flush any 
    let (full_bytes, leftover_bits) = (combined_nbits / 8, combined_nbits % 8);
    write_be_bytes(&mut self.data, combined >> leftover_bits, full_bytes);
    self.partial_byte = (combined & ((1u64 << leftover_bits) - 1)) as u8;
    self.bitpos += nbits;
  }

  pub fn byte_align(&mut self) {
    let partial_bits = self.bitpos % 8;
    if partial_bits == 0 {
      // Already aligned
      return;
    } else {
      let extra_bits = 8 - partial_bits;
      self.data.push(self.partial_byte << extra_bits);
      self.partial_byte = 0u8;
      self.bitpos += extra_bits;
    }
  }

  // Finalize the bit buffer and return the generated bytes.
  // In AV1, all OBUs must finish with an extra '1' bit, followed by enough zero
  // bits to align us to a full byte. The `add_trailing_one_bit` argument can be used
  // to add this trailing bit automatically.
  pub fn finalize(mut self, add_trailing_one_bit: bool) -> Box<[u8]> {
    if add_trailing_one_bit {
      self.write_bit(1);
    }

    self.byte_align();
    return self.data.into_boxed_slice();
  }
}
